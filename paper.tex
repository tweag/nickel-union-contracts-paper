\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\usepackage{amssymb}
\usepackage{mathtools,amsmath,amsfonts,amsxtra,amsthm,mathrsfs,mathpartir}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\usepackage{varioref}
\usepackage{verbatim,comment}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{url}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}

\definecolor{OliveGreen}{RGB}{128,128,0}
%%%%%%%%%%%%%%%%% Editing marks %%%%%%%%%%%%%%%%%

  % TOGGLE ME to turn off all the commentary:
  \InputIfFileExists{no-editing-marks}{
    \def\noeditingmarks{}
  }

  \usepackage{xargs}
  \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
  % ^^ Need for pgfsyspdfmark apparently?
  \ifx\noeditingmarks\undefined
      \setlength{\marginparwidth}{1.2cm} % A size that matches the new PACMPL format
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
      \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
      \newenvironment{alt}{\color{red}}{}

      \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
      \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
      \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
      \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
      \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
  \else
  %    \newcommand{\Red}[1]{#1}
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{#1}
      \newcommand{\note}[1]{}
      \newenvironment{alt}{}{}
  %    \renewcommand\todo[2]{}
      \newcommand{\unsure}[2][1=]{}
      \newcommand{\info}[2][1=]{}
      \newcommand{\change}[2]{}
      \newcommand{\inconsistent}[2]{}
      \newcommand{\critical}[2]{}
      \newcommand{\improvement}[1]{}
      \newcommand{\resolved}[2]{}
  \fi

%%%%%%%%%%%%%%%%% /Editing marks %%%%%%%%%%%%%%%%%

%%%%%%%%%%% LST listing confinguraiton %%%%%%%%%%%

\lstdefinelanguage{nickel}{
    keywords=[1]{
      if,
      then,
      else,
      switch,
    },
    keywords=[2]{
      let,
      rec,
      fun,
      in
    },
    keywords=[3]{
      forall,
    },
    keywordsprefix=\#,
    keywords=[4]{
      true,
      false,
      null
    },
    keywords=[5]{
      doc,
      default,
    },
    sensitive=true, % keywords are case-sensitive
    morecomment=[l]{//}, % l is for line comment
    morecomment=**[is][\color{gray}]{\$}{\$},
    morestring=[b]", % defines that strings are enclosed in double quotes
    morestring=[s]{m\#"}{"\#m},
    moredelim=[is][\color{gray}]{\$}{\$},
    literate=
        *{->}{$\rightarrow$}1
        {...}{\ldots}1
        {@&}{$\cap$}1
        {@|}{$\cup$}1
        {=>}{$\Rightarrow$}1
        {>=}{$\geq$}1
        {<=}{$\leq$}1
} %

% Copied from https://hal.inria.fr/hal-01140459/file/racket.inc.tex
\lstdefinelanguage{racket} {
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    define-context, define-controller, Integer, Boolean, get, when-required, when-provided,
    maybe_publish, require, submod, or/c, and/c, ->, \#\%module-begin,
    always_publish, with-syntax, define-struct/contract, syntax-case,
    define/contract,
    let-values, let*-values,
    module, provide,
    and, or, not, delay, force,
    \#`, \#',
    \#lang, implement, begin-for-syntax, rename-out,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsoletter={',`,-,/,>,<,\#,\%},
  morecomment=[l]{;},
%  literate={lambda}{{\lambdaup}}1, % lambda -- look at https://tex.stackexchange.com/questions/119879/math-symbols-in-tt-font
  moredelim=**[is][\color{light-gray}]{<<@<<}{>>@>>},
  moredelim=**[is][\itshape\color{OliveGreen}]{<<;<<}{>>;>>},
  morecomment=[s]{\#|}{|\#},
  sensitive=true,
}

% Copied from https://tex.stackexchange.com/questions/89574/language-option-supported-in-listings
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  % keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  % stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  language={nickel},
  basicstyle=\small\ttfamily, % Global Code Style
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=2, % number of spaces indented when discovering a tab
  columns=fixed, % make all characters equal width
  keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
  showstringspaces=false, % lets spaces in strings appear as real spaces
  breaklines=true, % wrap lines if they don't fit
  frame=trbl, % draw a frame at the top, right, left and bottom of the listing
  frameround=tttt, % make the frame round at all four corners
  framesep=4pt, % quarter circle size of the round corners
  numbers=left, % show line numbers at the left
  numberstyle=\tiny\ttfamily, % style of the line numbers
  escapeinside={(*@}{@*)} % escape sequence to insert latex
  % commentstyle=\color{dark-grey}, % style of comments
  % keywordstyle=[1]\color{blue-portage}, % style of keywords
  % keywordstyle=[2]\color{orange-vivid-tangerine}, % style of keywords
  % keywordstyle=[3]\color{blue-portage}, % style of keywords
  % keywordstyle=[4]\color{green-pea}, % style of keywords
  % keywordstyle=[5]\color{pink-froly}, % style of keywords
  % stringstyle=\color{blue-marguerite}, % style of strings
}

\lstset{
  escapeinside={(*@}{@*)} % escape sequence to insert latex
}
\newcommand{\nickel}[1]{\lstinline[language=nickel]{#1}}
\newcommand{\racket}[1]{\lstinline[language=racket]{#1}}
\newcommand{\haskell}[1]{\lstinline[language=Haskell]{#1}}
\newcommand{\typescript}[1]{\lstinline[language=JavaScript]{#1}}

\bibliographystyle{ACM-Reference-Format}

\begin{abstract}
This paper reports an attempt to incorporate union and intersection types in
Nickel, a configuration programming language with a gradual type system and
first-class contracts. While the end result looks appealing, it turns out the
concrete impact on both the design and the implementation of the language is
unexpectedly high. We review the issues raised in particular by the
implementation of contracts for unions and intersections, and why we think the
cost ends up too high for the benefit. We conclude by suggesting different leads
to represent and type unions.
\end{abstract}


\title{Contracts for unions and intersections are hard for Nickel}
\author{Teodoro Freund}
\affiliation{
  \institution{Universidad de Buenos Aires}
  \city{Buenos Aires}
  \country{Argentina}
}
\email{tfreund95@gmail.com}

\author{Yann Hamdaoui}
\affiliation{
  \institution{Tweag}
  \city{Paris}
  \country{France}
}
\email{yann.hamdaoui@tweag.io}
\author{Arnaud Spiwack}
\affiliation{
  \institution{Tweag}
  \city{Paris}
  \country{France}
}
\email{arnaud.spiwack@tweag.io}

\begin{document}

\maketitle

\unsure{TODO: CCS classification; Keywords}
\section{Introduction}
\label{sec:intro}
\info{Goals of the paper: position paper: unions/intersections nice in
theory problematic in practice. In particular non-orthogonal with the
rest of the features of your language.}

Union types, meaning a type \nickel{A @| B} containing values which
belong either to a type \nickel{A} or \nickel{B}, are a popular tool
when adding a static types to a dynamic language. In particular, both
TypeScript~\cite{TypeScriptUnions} and MyPy~\cite{MyPyOptional}, use
union types to model the frequent practice to use the value
\lstinline{null} (\lstinline{None} in Python) to represent an absent
optional value. This is why the gradual typing literature, concerned
with formalising the interplay between static and dynamic type
systems, has been quite interested in union
types~\cite{RootCauseOfBlame,KeilThiemannUnionIntersection}.

On the other hand, unions are not a common feature of static type
systems, mostly because they are quite difficult to verify
statically. So unions are really only worth it in gradually typed
language where they formalise existing dynamically typed patterns. On
the other hand, surely, for dynamic tests, unions are really easy: it
is simply the Boolean disjunctions of two tests.

Unfortunately, as we document in this article, as soon as you extend
dynamic checks to \emph{contracts}~\cite{FindlerFelleisenHOContracts},
unions become actually pretty difficult, and threaten desirable
properties of your language.

\subsection*{Configuration languages}

To motivate contracts and the problem caused by unions, let's make a
detour through configuration languages.
%
A configuration language is a language concerned with describing the
configuration of an application. In traditional configuration
languages, such as YAML, TOML, or JSON, the configuration is fully,
and explicitly, spelt out.

However, with the advent of DevOps, configurations have been extended
to describe the entire state of a computer, or even a fleet of
computers. For instance, with Kubernetes you need to configure a large
fleet of (possibly replicated) docker containers. To describe this
sort of configurations, you really want to be able to re-use and
abstract parts of the configuration, like traditional programming
languages do. To meet this need, languages such as Cue~\cite{cueLang},
Dhall~\cite{dhallLang}, Jsonnet~\cite{jsonnetLang}, or Nickel~\cite{NickelRepo}, where
configurations are generated rather than spelt out, were created.

Another example is continuous integration systems: it's fairly typical
to need a matrix of jobs, wherein the same tests are run on different
infrastructures, or with different versions of a compiler. Traditional
configuration would have you copy the same steps for each
infrastructure. This is tedious, hard to maintain, and error
prone. It's much better, instead, to write the steps once, and
instantiate them for each infrastructure. Continuous integration
systems typically do this using a templating system layered on top of
YAML. Each of the configuration-generating languages above allow such
job-matrix definition natively.

\subsection*{Nickel}

In this article, we will use the Nickel language~\cite{NickelRepo} as
illustration and motivation. At its core, Nickel is the JSON data
model, that is dictionaries (written \nickel{\{field1 = value1, ...,
  fieldn = valuen\}}) and arrays (\nickel{[x1, ..., xn]}), augmented
with functions (\nickel{fun arg1 ... argn => body}) and
let-definitions (\nickel{let id = value in exp}).\unsure{Arnaud: this
  paragraph looks kind of bad, maybe it'll be better to put each
  syntax entry in an enumeration, we will see if there is still room
  for this}

A Nickel configuration is then evaluated to an explicit configuration,
\emph{e.g.}  in JSON, which can then be consumed by an
application. Therefore a design constraint of Nickel is any Nickel
data must have a straightforward interpretation in JSON.

\subsection*{Contracts}

A useful feature of a configuration language is to provide facilities
for schema validation. That is, help answer questions like: does our
configuration have all the required fields? does the \nickel{url} field indeed
contains a URL?

These are inherently dynamic questions, as they are all questions
about the evaluated configuration. To this effect, Nickel lets us
annotate any expression with a dynamic schema check: \nickel{exp |
  C}. There is also syntactic sugar to annotate definitions:
\nickel{let id | C = value in exp} stands for \nickel{let id = (value
  | C) in exp}.\unsure{This point used to be made, do we want to
  reinsert it? However, Nickel programs are of a special kind: they are usually
simple, terminating programs that run on fixed inputs. Correctness errors will
show up at evaluation anyway, or will not matter (dead code).}

Let us pause for a moment and consider the following: it is Nickel's
ambition to be able to manipulate configurations like Nixpkgs. With
over 50\,000 packages, is one of the largest repository of software
packages in existence~\cite{repology}. Concretely, Nixpkgs is a
dictionary mapping packages to build recipes. That is, a massive,
over-50\,000-key-value-pair wide dictionary. It is absolutely out of the
question to evaluate the entirety of this dictionary every time one
needs to install 10 new packages: this would result in a painfully
slow experience.

To be able to support such large dictionaries, Nickel's dictionaries
are \emph{lazy}, that is, the values are only evaluated when
explicitly required. For instance, when writing
\hbox{\nickel{nixpkgs.hello},} only the \nickel{hello} package gets
evaluated.

But let's consider now writing something like \nickel{nixpkgs |
  packages}, to guarantee that all the packages conform to the desired
schema. If this were a simple Boolean test, it would have to evaluate
all 50\,000 package to check their validity, hence breaking the
laziness of dictionaries. Do we have to choose between laziness and
schema validation? Fortunately, we don't! Enter
\emph{contracts}~\cite{FindlerFelleisenHOContracts}: dynamic check
which can be partially delayed, yet errors can be reported
accurately. Contracts can respect laziness of dictionaries, and they
can be use to add schema validation to functions as well (in fact
functions were the original motivation for contracts).

There is no Boolean function which can check that a value has type
\nickel{Str -> Str}. Instead, a contract for \nickel{Str -> Str}
checks for each call of the function whether
\begin{enumerate}
\item the argument has type \nickel{Str}, otherwise the caller of the
  function is faulty
\item if so, that the returned value has type \nickel{Str}, otherwise
  the implementation of the function is faulty
\end{enumerate}

Like in the case of lazy dictionaries, the checks are delayed.
Contracts keeps track of whether the caller or the implementation is
at fault for a violation, hence it can report precise error
messages. Compare Figure~\ref{fig:contract-reporting-wo} and
Figure~\ref{fig:contract-reporting-w}: in
Figure~\ref{fig:contract-reporting-wo} an error is reported inside the
\nickel{catHosts} function, but \nickel{catHosts} is, in fact,
correct, as is made clear by Figure~\ref{fig:contract-reporting-w},
where \nickel{catHosts} is decorated with the \nickel{Str -> Str}
contract, and correctly reports that the caller failed to call
\nickel{catHosts} with a string argument.

\begin{figure*}
  \centering
  \begin{subfigure}[b]{0.48\linewidth}
    \begin{lstlisting}[language=nickel]
let catHosts = fun last =>
  let hosts = ["foo.com", "bar.org"] in
  lists.fold (fun val acc => val ++ "," ++ acc) hosts last in

let makeHost = fun server ext =>
  server ++ "." ++ ext in

catHosts (makeHost "google")
\end{lstlisting}

    \begin{lstlisting}[frame=none,numbers=none, basicstyle=\footnotesize\ttfamily]
error: Type error
3 | [(*@{\ldots}@*)] "," ++ acc) hosts last in
  |            ^^^
  | This expression has type Fun,
  | but Str was expected
4 |
5 | let mkHost = fun server ext => [(*@{\ldots}@*)] in
  |              -----------------------
  |              evaluated to this
  = ++, 2nd argument
\end{lstlisting}
    \caption{Error reporting without contract}
    \label{fig:contract-reporting-wo}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.48\linewidth}
    \begin{lstlisting}[language=nickel]
let catHosts | Str -> Str = fun last =>
  [(*@{\ldots}@*)]
\end{lstlisting}
\vspace{10ex}
    \begin{lstlisting}[frame=none,numbers=none, basicstyle=\footnotesize\ttfamily]
error: Blame error: contract broken by the caller.
  |  Str -> Str
  |  --- expected type of the argument [(*@{\ldots}@*)]
[(*@{\ldots}@*)]
1 | let catHosts | Str -> Str = fun last =>
  |                ^^^^^^^^^^ bound here
[(*@{\ldots}@*)]
6 | catHosts (makeHost "google")
  | --------------------------- (2) calling <func>
    \end{lstlisting}
    \caption{Error reporting with contract}
    \label{fig:contract-reporting-w}
  \end{subfigure}
  \caption{Contracts improve error messages}
\end{figure*}

Unfortunately, the delayed check of contract, while essential to
ensuring that schema validation doesn't affect performance (or, indeed,
is possible at all on functions), make union contracts (and their less
appreciated sibling, intersection contracts) quite problematic.

\subsection*{Structure of this paper}
\unsure{Make this section into a contributions section?}
Section~\ref{sec:intro} introduced the perspective of designing a configuration
language. We presented the concept of contracts and detailed why contracts are
particularly fitted for a configuration language, and more generally for data
validation or program correctness in a dynamically typed language. The rest of
the paper is structured as follows:
\begin{itemize}
    \item Section~\ref{sec:feat-lang} outlines various common features of
        programming languages that may interact in a bad way with union and
        intersection contracts.
    \item Section~\ref{sec:union-inter} introduces unions and intersections and
        lists the possible motivations for adding them to a language.
    \item Section~\ref{sec:issues-sem} studies intrinsic difficulties one may
        encounter when trying to implement union and intersection contracts in
        practice.
    \item Section~\ref{sec:issues-literature} presents the shortcomings found in
        existing attempts to solve said difficulties.
    \item Section~\ref{sec:related-work} provides some related work.
\end{itemize}

Section~\ref{sec:conclusion} concludes the paper.


\section{A typology of language features}
\label{sec:feat-lang}
\info{Zoology of various features that we will eventually show
  conflict with this or that property or implementation of union and
  intersection. Including user-define contracts.}

Union contracts are not only difficult to implement, their
unrestricted presence is incompatible with potentially desirable
properties of the language. In this section we present some of these
properties; we will show how these properties interact with union
contracts in Sections~\ref{sec:issues-sem}
and~\ref{sec:issues-literature}.

\subsection*{User-defined contracts}
\label{sec:flat-contracts}

A strength of dynamic checking is that we can easily check properties which
are impractical to check statically. For instance that a string
represents a well-formed URL, or a number is a valid port.

This same property is desirable of contracts as well, otherwise we
lose an important benefits of dynamic checking. Preferably, we want to
be able to extend the universe of contracts with user-defined
predicates (sometimes called flat contracts).

For instance, Figure~\ref{fig:port-contract} shows the definition of a
contract for valid ports in Nickel syntax.

\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel]
let Port = contracts.fromPred (fun p =>
  num.isInt p && 0 <= p && p <= 65535) in
80 | Port
\end{lstlisting}
\end{center}
\caption{A contract for valid ports}
\label{fig:port-contract}
\end{figure}

User-defined contracts can be combined with other contracts normally,
for instance \nickel{Int -> Port} is a contract verified by functions
which, given an integer returns a valid port.

This type of contracts are present on many different languages,
for instance, the Eiffel programming language\cite{meyer1987eiffel}, the precursor
of the Design by Contract ideals, allows to assert
these kinds of expression as pre- and post-conditions on
functions and as invariants on classes\cite{EiffelDesignByContract}.

The Racket programming language also has a system to work with
contracts, powerful enough to define flat contracts, and
to compose them with other kinds of dynamic checks,
like higher order contracts or a lightweight take on union
and intersection contracts\cite{RacketContracts}.


\subsection*{Purity}
\label{sec:optimizations}
\info{Present inlining and CSE as two major code
optimizations.
Purity and immutability as two important factors.}

\unsure{I (Arnaud) changed the title of this subsection. Maybe it's
  not the best one, but if it is, then we ought to reorder the section
  a little bit to fit the modified narrative.}

The performance of modern programs heavily relies on the optimizations performed
by the compiler or the interpreter. Even more so for functional languages, whose
execution model is often far removed from actual processors, causing naive
execution to exhibit unacceptable slowdowns.

One crucial optimization is
inlining (Figure \ref{fig:optimizations-inlining-ex}). Functional programs tend
to make heavy use of functions, and a function call is a costly operation from
the point of view of low-level execution. Inlining eliminates a function
application by directly substituting the function for its definition at compile
time (or before execution, for interpreted language). This is especially
efficient for small functions that are called repeatedly.

\info{I think it's better to use [h] on figures, we can discuss it}
\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elem = fun elt =>
  lists.any (fun x => x == elt) in

let subList = fun l1 l2 =>
  elem (lists.head l1) l2
  && subList (list.tail l1) l2
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let subList = fun l1 l2 =>
  lists.any (fun x => x == (lists.head l1)) l2
  && subList (list.tail l1) l2
\end{lstlisting}
  \end{center}
\caption{Inlining}
\label{fig:optimizations-inlining-ex}
\end{figure}

While inlining expands an expression by substituting a definition for its value,
an opposite transformation is sometimes beneficial, for example when a composite
expression is repeated several times. This causes the same expression to be
wastefully recomputed at each occurrence. Common subexpression elimination (CSE)
consists in introducing a new identifier for this expression and using the
identifier in place of the original occurrences
(Figure \ref{fig:optimizations-cse-ex}), computing the result once and for all.

\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elemAtOrLast = fun index list =>
  if index > lists.length list - 1 then
    lists.elemAt (lists.length list - 1) list
  else
    lists.elemAt index list
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let elemAtOrLast = fun index list =>
  let l = lists.length list - 1 in
  if index > l then
    lists.elemAt l list
  else
    lists.elemAt index list
\end{lstlisting}
  \end{center}
\caption{Common subexpression elimination}
\label{fig:optimizations-cse-ex}
\end{figure}

Beyond CSE, optimizations such as loop-invariant code motion or
let-floating~\cite{letFloating} apply the same principle of extracting out an invariant
expression to avoid its recomputation respectively across loop iterations and
function calls.

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let f = fun x => g y (x + 1)
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let g' = g y
let f' = fun x => g' (x + 1)
\end{lstlisting}
  \end{center}
\caption{Let-floating}
\label{fig:optimizations-let-floating-ex}
\end{figure}

For example, take the code of Figure~\ref{fig:optimizations-let-floating-ex}.
The partial application \lstinline+g y+ is recomputed each time \lstinline+f+ is
called. This may be costly, in particular in the presence of contracts: if
\lstinline+y+ is a list for example, and \lstinline+g+ applies a list contract
on it, the cost could be linear in the size of \lstinline+y+. A sensible thing
to do is to factor \lstinline+g y+ out of \lstinline+f+ as in
Figure~\ref{fig:optimizations-let-floating-ex}, which is something a
let-floating transformation could indeed do (given \lstinline+g+ is pure, as
explained below).

The soundness of all these optimizations is tied to the invariance of the
semantics of programs with respect to specific substitutions. Inlining requires
that one can replace the application of a function by its body, which is
basically $\beta$-reduction: as long as the arguments are evaluated following
the language's strategy, it is a valid transformation. On the other hand,
a CSE-like transformation on a term $M$ requires an expansion property of the form

\begin{equation}\label{eq:cbn-expansion}
M[x/N] \simeq let~x~=~N~in~M
\end{equation}

Here, $M[x/N]$ is the substitution of $x$ for $N$ in the term $M$.
\ref{eq:cbn-expansion} has an evident call-by-name flavour, and consequently
fails in general for a call-by-value language with side effects.  Indeed, define
the following function $f$:

\begin{lstlisting}[language=Nickel]
let f x = print "hi";(x+1) in
\end{lstlisting}

Then:

\begin{lstlisting}[language=Nickel]
(f 1,f 1) (*@ $\not \simeq$ @*) let y = f 1 in (y,y)
\end{lstlisting}

In the example above, the first term prints \nickel{"hi"} two times while the
second term prints it only once. However, \ref{eq:cbn-expansion} does hold for
\emph{pure} terms, that are terms without side-effects. In a pure language, or a
language with effect tracking like Haskell\todo{Cite a different language, or
remove citation}, pure terms can be safely identified for applying
optimizations.

Strikingly, we will see in section~\ref{sec:issues-sem} that the introduction of
unions and intersections can make \ref{eq:cbn-expansion} unsound
\emph{even in a pure setting}, making the optimization of
Figure~\ref{fig:optimizations-let-floating-ex} unsound in general.


\section{Union \& intersection}
\label{sec:union-inter}
\info{What are they, what are they used for.}

% Goals:
% Introduce unions and inter
% Why are they useful?
% How are they used
% How de they relate with one another

\subsection*{Unions}
Unions ($\cup$) are a fundamental building block of programs.
A union holds a value whose
shape is known to be in a fixed set of alternatives, without exposing
which of those alternatives the value belongs to.
For example, a value that could be either a Number or a String can be
modelled using unions as \nickel{Num @| String}.
They correspond logically to disjunctions.

Statically typed languages, and more specifically functional programming
languages, provide a similar abstraction, sums
(also called tagged unions, or discriminated unions), which
also allow to model a value whose shape conforms to a fixed set of
alternatives, but requiring an explicit mark (or tag) that differentiates
to which of these alternatives it belongs to.
For example, consider the Haskell code presented on Figure
\ref{fig:safediv-haskell}, it's a safe division that will
check if the dividend is 0, and if it is, return an
error message.
Since the function can return two different types, a sum
(\haskell{Either}) is used, and on each
of the if branches an explicit tag has to be used (either
\haskell{Left} or \haskell{Right}).

\begin{figure}[h]
\begin{lstlisting}[language=Haskell]
safeDiv :: Int -> Int -> Either String Int
safeDiv x y =
  if y == 0 then
    Left "Division by 0 is forbidden"
  else
    Right (div x y)
\end{lstlisting}
\caption{Safe division implemented in Haskell}
\label{fig:safediv-haskell}
\end{figure}

This incurred verbosity certainly facilitates the work of static checks,
like typechecking, but dynamically typed languages permit much more flexibility,
and programmers don't usually expect to tag their values.
That is why, as mentioned on the Introduction, when designing
type systems for dynamically typed languages, unions become of particular
interest.
See the implementation of a safe division function on TypeScript
(Figure \ref{fig:safediv-ts}).
Neither of the if branches has to tag their return value, and the return
type of the function is modelled using unions, \typescript{string | number}.


\begin{figure}[h]
\begin{lstlisting}[language=JavaScript]
function safeDiv(x: number, y: number): string | number {
  if (y == 0) {
      return "Division by 0 is forbidden"
  } else {
      return x/y
  }
}
\end{lstlisting}
\caption{Safe division implemented in TypeScript}
\label{fig:safediv-ts}
\end{figure}

% \begin{figure}[h]
% \begin{lstlisting}[title={Tree-like data structure}]
% type BinaryTree =
% Integer @| (BinaryTree, BinaryTree)
% \end{lstlisting}
% \caption{A binary tree data type using unions}
% \label{fig:union-adt-ex}
% \end{figure}

Unions are not only useful to model the outcome of alternative
branches of computations, but they can be used to
formalize very common patterns of data types:
\begin{itemize}
    \item To represent nullable, or optional, values.
\begin{lstlisting}[language=nickel]
optionalValue : Str @| Null
\end{lstlisting}

    \item For plain enumerations of literals.
\begin{lstlisting}[language=nickel]
protocol : "Http" @| "Ftp" @| "Sftp"
\end{lstlisting}

    \item To support different representations of the same data.
\begin{lstlisting}[language=nickel]
person : {name : Str, age : Int}
  @| {name : Str, dateOfBirth : Date}
\end{lstlisting}

\end{itemize}
All of which are common in configurations.

% \begin{figure}[h]
% % \label{fig:union-nullable-ex}
% \begin{lstlisting}[title={Nullable values}]
% optionalValue : Str @| Null
% \end{lstlisting}

% % \label{fig:union-enum-ex}
% \begin{lstlisting}[title={Plain enumeration}]
% protocol : `Http | `Ftp | `Sftp
% \end{lstlisting}

% % \label{fig:union-alt-ex}
% \begin{lstlisting}[title={Alternative representations}]
% person : {name : Str, age : Int}
%   @| {name : Str, dateOfBirth : Str}
% \end{lstlisting}
% \caption{Various use cases of unions}
% \label{fig:unions-use-cases}
% \end{figure}

% In statically typed languages, and more specifically in functional programming
% languages, sums (also called tagged unions, or discriminated unions) are usually
% preferred, as constructors for algebraic datatypes. [references]. Sums are unions' cousin where the alternatives are
% syntactically separated by an associated discriminating label. Well-known
% programming languages with first-class tagged unions include Haskell, OCaml,
% Rust, Scala, PureScript, Elm, Swift and many more.

% On the other hand, in dynamically typed languages, it is customary to directly
% store different kinds of data in one variable without further ceremony. The
% runtime system needs to attach type tags to values anyway, which can usually be
% observed using functions like JavaScript's \verb+typeof+. Using such bare
% unions\resolved{If you can observe with typeof, then it's pretty much a tagged
% union, though the tag is implicit} has already been an idiom in dynamically
% typed language for a long time. Being able to type and handle these unions is an
% important aspect of the migration to a gradual type system. Indeed, a lot of
% \resolved{This is the first time discussing gradual type systems, maybe it should
% be introduced earlier, in particular how they relate to contracts
% (I think is mentioned on the appendix)}
% gradually typed languages either existed originally as dynamically typed
% language or aim at backward compatibility with a dynamically typed base
% language. This is why despite the presence of a static type system, gradually
% typed languages tend to favor bare unions types which is the typed counterpart
% of this practice (as e.g in TypeScript \cite{TypeScriptUnions}).

Nickel has no pre-existing untyped language that we have to
support, so we are freer of our choice.
However, Nickel is a configuration language, whose contract and type system
is intended to encode data schemas encountered in the wild. Since these schemas do not use
tags to differentiate different kinds of values, there is a strong incentive to support untagged unions at the
type level, or at least, at the contract level.

We have shown how values of a union are built, is worth mentioning
how they are used.
For instance, consider the TypeScript function on Figure \ref{fig:addElem},
we want it to insert an element to a list that is either an
\typescript{Array<string>} or an \typescript{Array<number>},
what value could we fill \typescript{...} with for this to typecheck?
Since we don't know what's the shape of \typescript{list},
we can't know whether to push a \typescript{string} or a
\typescript{number}.
That is, when using a union, we have to treat it as if it where any one
of the alternatives, in the case of the example, we should provide
it with a value that is both a \typescript{string} and a \typescript{number}.

\begin{figure}[h]
\begin{lstlisting}[language=JavaScript]
function addElem(list: Array<string> | Array<number>) {
  list.push(...)
}
\end{lstlisting}
\caption{Adding an element to a union of two arrays}
\label{fig:addElem}
\end{figure}



\subsection*{Intersections}

Intersections ($\cap$) are less prevalent. An intersection is a value that belongs to
two types at the same time. An example is a number literal \nickel{1}
which could be accepted as both an \nickel{Int} and a \nickel{Float} without
having to perform conversions.
In that case, a value of type \nickel{Int @& Float} can be used as a value of
both type \nickel{Int} and \nickel{Float}.

% \label{fig:intersection-subytping-ex}
% \begin{lstlisting}[title={Value subtyping}]
% 1 : Int @& Float
% \end{lstlisting}

The real usability of intersections shows up when intersecting
functions, since it can be used to encode overloading.
For instance, take a look at Figure
\ref{fig:intersection-overloading-ex}, where the function
\nickel{duplicate} works both as a function to duplicate
arrays, as well as a function to duplicate strings.
This is particular useful when using unions, since it's a
good way to express that a function can deal with different
shapes of data.
For instance, on the same figure, you can use \nickel{duplicate}
over some value with type \nickel{[String] @| String}, and know
that it will work correctly.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let duplicate | ([String] -> [String]) @& (String -> String) =
  fun x => x ++ x in
let text | [String] @| String = ... in
duplicate text
\end{lstlisting}
\caption{Duplicating an array of Strings or a String}
\label{fig:intersection-overloading-ex}
\end{figure}


% \label{fig:intersection-overloading-ex}
% \begin{lstlisting}[title={Overloading}]
% incr: (Int -> Int) @& (Float -> Float) =
%   fun x => x + 1
% \end{lstlisting}

They can also be used to combine dictionaries in an object-oriented fashion. For instance, in Figure \ref{fig:intersection-record}
two types are defined \nickel{Animal} and \nickel{Pet}, and
a variable that is compatible with both types is declared, with
type \nickel{Animal @& Pet}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let Animal = { species: Str, race: Str } in
let Pet = { owner: Str, name: Str } in
let myDog | Animal & Pet =
  { species = "Canis Lupus",
    race = "Australian Cattle Dog",
    owner = "Anonymous Author",
    name = "Juno" }
\end{lstlisting}
\caption{An animal that is also a pet}
\label{fig:intersection-record}
\end{figure}

% They can also be used to combine constraints (such as traits or interfaces),as
% done in Scala 3 (Figure~\ref{fig:intersection-mixins-ex}).

% \label{fig:intersection-mixins-ex}
% \begin{lstlisting}[language=Scala,title={Structural mixins}]
% Comparator: {cmp: T -> T -> Bool}
% Shower: {show: T -> String}

% showSmaller : (dict: Comparator & Shower) -> T -> T -> String
% \end{lstlisting}

Finally, intersection naturally show up as the dual of unions.
Thus, in a system
featuring unions, a union in a negative positions is a form of intersection
(Figure~\ref{fig:intersection-dual}).

\begin{figure}[h]
\begin{lstlisting}[language = nickel]
f : (Num @| Str) -> Bool
(*@ $\simeq$ @*) f : (Num -> Bool) @& (Str -> Bool)
\end{lstlisting}
\caption{Intersection as the dual of unions}
\label{fig:intersection-dual}
\end{figure}

\resolved{Either here or the next section, show examples of unintuitive behaviour
of U and I. For example, I is not jos composition of contracts.
And union has to be treated as any one of the options.
Kindo of resolved for unions}
% Things to settle: how to motivate them, how to compare them to ADTs. Purely
% dynamic approach, or typed approach too?



\section{Issues coming from the semantics}
\label{sec:issues-sem}
\info{What goes wrong or difficult when trying to implement union and
  intersection literally}

Static typing is about enforcing that some property about a (potentially
unknown) value always holds, no matter the execution path. A dynamic check, on
the other hand, just needs to verify a property for a specific and known value,
which is usually much easier. For example, dependent function types are complex
and mostly implemented in proof assistants (although they are slowly making
their way in some mainstream languages), whereas the corresponding dependent
function contracts can be implemented in a straightforward way (they are
supported in e.g. Racket~\cite{}).

The gist of the present paper is to bring evidence that in the case of unions
and intersections, the dynamic checking part is complex as well: \emph{unions
and intersections are fundamentally hard}.

% Teo's version
% Implementing a static type system is not an easy task.
% Type systems featuring intersection types are hard in a fundamental way,
% from their discovery, they've been studied as a form to characterize
% lambda-calculus terms normalizability; which means that typechecking a
% term on a system with intersection types is undecidable,
% similar to how the halting problem is undecidable\todo{reference}.
%
% Usually, when thinking about programming languages, there's an intuition
% that static checks (like typechecking) are more difficult and less powerful
% than dynamic checks (like testing).
% For instance, it is very easy to check if,
% in a given execution of a program, a variable holds an integer value; while it
% may become more challenging to check if a variable will always hold an integer value,
% no matter the particular execution.
%
% As we intend to show on this paper, unions and intersections are not only
% statically hard to check, but they are also dynamically hard:
% \emph{they are fundamentally hard}.
% In this section, we present intuitively the main challenges that arise
% when attempting to develop a runtime check system for unions and intersections.

\subsection*{Union contracts as a side-effect}

In Nickel, the failure of a function contract can always be traced back to a
single call. For example, take the function \nickel{f} with a simple contract
attached of Figure~\ref{fig:pos-to-pos}. The whole program fails with a contract
error blaming \nickel{f} because the return value of the second call \nickel{f 5}
violates the \nickel{Positive} contract. The first call to \nickel{f} does
not matter, and \nickel{f 5} is a single and independent witness of the contract
violation. The user is pointed to this one location in practice.

This single witness property can be justified as follows. Apart from the error
reporting part (although this is the crucial bit in practice!), the current
contract system of Nickel can be implemented purely as a library, requiring only
a \nickel{fail} primitive to abort the execution. In practice, applying a
function contract to \nickel{f} replaces it with a \nickel{f'} that performs the
additional checks. Thus, since the core language is pure (forgetting the
presence of \nickel{fail}, which isn't relevant), the failure of \nickel{f' 5}
must be independent of its environment and of any previous call to \nickel{f'}.

% When programming with dynamic checks it is assumed that lack of
% failure does not mean that the program works perfectly.
%
% For instance, imagine having a function wrapped in a contract
% that checks that it maps positive numbers to positive numbers,
% and using it in different ways,
% like the program on Figure \ref{fig:pos-to-pos}.
% Clearly, there is an error on this program, but if the first call
% to \nickel{f} that gets executed is \nickel{f 10}, the error will not
% be found at that point, and the first operand of the addition would be
% evaluated to \nickel{3}.
% If, later on, \nickel{f 5} gets executed, the contract would get violated,
% since \nickel{f} gets called with a positive value, but returns a negative
% one (\nickel{-2}).

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f | Positive -> Positive
      = fun x => x - 7 in
(f 10) + (f 5)
\end{lstlisting}
\caption{Simple contract violation}
\label{fig:pos-to-pos}
\end{figure}

% Even if the program performed two different applications of \nickel{f}
% before finding the contract violation, the first one is not actually
% needed, and executing only \nickel{f 5} is enough to find the problem.
%
% Having a witness of size 1 for every contract failure is a really nice to have property
% since it means, for example, that every time that a contract is violated,
% the stack trace is enough to understand how it was violated, and to potentially
% come up with a minimal example that breaks the contract.
% However, when unions get introduced, this property is lost.

Union contracts are different. Consider the program presented in
Figure~\ref{fig:wrong-union-function}. The same \nickel{f} is now given a union
contract. \nickel{f} is violating this contract once again, as it neither maps
positive numbers to positive numbers nor positive numbers to negative numbers.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f | (Positive -> Positive)
        @| (Positive -> NonPositive)
      = fun x => x - 7 in
(f 10) + (f 5)
\end{lstlisting}
\caption{Union contract violation}
\label{fig:wrong-union-function}
\end{figure}

This program must fail, because \nickel{f 10} is a witness of \nickel{f} failing
the contract \nickel{Positive -> NonPositive}, and \nickel{f 5} is a witness of
\nickel{f} failing \nickel{Positive -> Positive}.  But, as opposed to the
example from Figure~\ref{fig:pos-to-pos}, removing only one of the calls makes the
program succeed! Indeed, each call only unveils the violation of one component
of the union. In this example, a single call to \nickel{f} that would be the
witness of the violation of the whole contract doesn't even exist: a minimum of
two are always needed.

This behavior indicates that union contracts introduce side-effects. The result
of \nickel{f 5} now depends on the previous execution and more specifically on
any prior call to \nickel{f}. This behavior of union contracts break the
property~\ref{eq:cbn-expansion} introduced in Section~\ref{sec:optimizations},
that is required to perform CSE-like optimizations in all generality. The
candidate example of Figure~\ref{fig:optimizations-let-floating-ex} in
Section~\ref{sec:optimizations} can't be optimized in general.

Figure~\ref{fig:optimized-programs} illustrates this point further. It contains
an original program and an optimized version where the common subexpression
\nickel{f 1} has been eliminated. While equivalent in a pure language without
contracts, these two programs behave differently because of unions:

\begin{itemize}
    \item The original version returns \nickel{(1, "False")} without failing.
    \item The optimized version fails with a contract violation.
\end{itemize}

In the original version, each partial application \nickel{f 1} gives rise to a
fresh instance of the contract \nickel{Bool -> Num @| Bool -> Str}. These
instances are independent, and can pick a different component of the union to
satisfy. Although \nickel{f} doesn't actually respect the contract, these calls
are not enough to prove so. In the optimized version, \nickel{g} is endowed with
a single contract, that must pick one of the two components of the union. There,
the two calls refer to the same union contract, and shows that \nickel{f} does
violate its initial contract.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Original]
let f | Num -> (Bool -> Num @| Bool -> Str)
      = fun x y => if y then x else "False"
in (f 1 true, f 1 false)
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Optimized]
let f | Num -> (Bool -> Num @| Bool -> Str)
      = fun x y => if y then x else "False"
let g = f 1 in
(g true, g false)
\end{lstlisting}
\caption{Equivalent programs, with inlining or CSE applied}
\label{fig:optimized-programs}
\end{figure}

To sum up, the addition of union contracts introduce side-effects in a pure
language. Side-effects have well-known pitfalls:
\begin{itemize}
    \item For the programmer, they are hard to reason about. They prevent local
        reasoning. In our previous examples, removing or adding a function call
        somewhere can toggle a failure in a call at a totally different
        location.
    \item For the interpreter (or compiler), side-effects inhibit many optimizations and
        program transformations.
\end{itemize}


% A valid argument against this point would be stating that further work should be done
% on optimizers, so to not modify these tricky cases, even if this is true,
% programmers also modify their code on a daily basis, and if moving from the first
% code snippet at Figure \ref{fig:optimized-programs} to the second one changes
% the behaviour of a program, we argue that union contracts not only go against the
% implementation of languages, but also against their usability.
%
% Summing it up, wrapping a value with a union of higher order contracts means that
% that value now has a state, that may get modified silently at every use site.
% Both reviewed papers suffer from this defect since it is the semantics
% of unions that interact badly with code manipulation operations,
% not a particular implementation.
% This addition of global state complicates both the work of the language
% implementor, as well as the language user, since it adds non trivial
% side effects to your code.


\subsection*{Intersection with user-defined contracts}
\label{sec:flat-and-inter}

A natural - but naive - implementation of intersection contracts could be the
following: to apply a contract \nickel{A @& B}, apply both contracts \nickel{A}
and \nickel{B} sequentially, resulting in the naive decomposition rule of
Figure~\ref{fig:naive-impl}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel,frame=none,numbers=none,title={Naive
decomposition}]
M | A @& B (*@ $\simeq$ @*) (M | A) | B
\end{lstlisting}
\begin{lstlisting}[language=nickel,frame=none,numbers=none,title={Exchange law}]
(A -> B) @& (C -> D) (*@ $\simeq$ @*) (A @& C) -> (B @& D)
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Overloaded identity}]
let g | Num -> Num @& Str -> Str
      = fun x => x in
g 1
\end{lstlisting}
\caption{Naive implementation of intersection}
\label{fig:naive-impl}
\end{figure}

This intuition works for simple contracts: checking that \nickel{x | Natural @&
Odd} amounts to check that \nickel{x | Natural} and \nickel{x | Odd}.
Unfortunately, this doesn't scale to higher-order contracts.  The overloaded
identity example of Figure~\ref{fig:naive-impl} illustrates the use of an
intersection to model a simple overloading of the identity function. If we were
to apply the naive decomposition, the argument \nickel{1} would fail the
\nickel{Str -> Str} contract and abort the execution. Perhaps the exchange rule
given in Figure~\ref{fig:naive-impl}, which is a direct consequence of the naive
decomposition, illustrates the issue better. It is clear that this exchange law
isn't the right semantics for overloading. With this law, the contract for
overloaded identity of Figure~\ref{fig:naive-impl} would always fail because
no argument can satisfy \nickel{Num @& Str}.

% Stop for a second and think how you could implement an intersection contract.
% The first thought you may have is "just apply both contracts", as shown on the
% Implementation snippet from Figure \ref{fig:inter-contracts}.  Of course, if
% it were that simple we wouldn't be writing this paper.  This idea starts to
% show problems when you first combine it with higher order contracts, since it
% would mean not complying with at least one of these contracts negatively would
% entail breaking the whole thing, as shown on the second example on the same
% Figure, that would fail.

In an higher-order intersection contract, blame is raised when:
\begin{description}
    \item[Negative blame] The argument fails \emph{both} components.
    \item[Positive blame] The function fails \emph{one} component that the
        argument previously satisfied.
\end{description}

% Not all hope is lost, we could pass some extra shared state
% to each one of the sub contracts and let them only fail if the other
% side of the contract has failed as well, as shown in Figure
% \ref{fig:inter-contracts-2}, where the shared state is
% represented by a label \nickel{l}.
% This idea is still quite reasonable, for instance, when executing
% \nickel{g 1}, from Figure \ref{fig:inter-contracts}, the first contract
% that gets checked is the argument of \nickel{Str -> Str} over the function parameter, so
% something like \nickel{1 | Str}.
% Of course, this fails, but before raising a violation, this contract could
% check if the other side of the intersection (\nickel{Num -> Num}) has
% also tried to raise negative blame on the same parameter ()\nickel{1}), since
% it hasn't, the contract would return normally, and would mark itself as failed.

% On the other hand, if you were to do something like
% \nickel{g true}, that would fail also negatively the contract
% \nickel{Str -> Str} and, when checking if \nickel{true}
% is a correct parameter for \nickel{Num -> Num} it would check
% if the other side of the intersection has failed, and since it
% has, a violation would be raised and the whole program would
% correctly fail.
%
% This idea, which is an oversimplification of the ideas
% presented by Williams, Morris, and Wadler, seems to be spot on.

To fix the naive implementation, the interpreter can share state between the
sub-contracts, in order to decide if blame must be raised or not when a
sub-contract fails:

\begin{lstlisting}[language=nickel,frame=none,numbers=none]
x | A @& B (*@ $\simeq$ @*) (x | A[l]) | B[l]
\end{lstlisting}

Shared state is represented by the label \nickel{l}. This is in essence the
approach proposed by Williams, Morris, and Wadler in~\cite{RootCauseOfBlame}.

% \begin{figure}[h]
% \begin{lstlisting}[language=nickel, title=Implementation]
% x | A @& B (*@ $\simeq$ @*) (x | A[l]) | B[l]
% \end{lstlisting}
% \caption{Implementations of intersection contracts: second iteration}
% \label{fig:inter-contracts-2}
% \end{figure}


% However, it presents a major problem, it's not compatible with user defined contracts,
% as presented in Section \ref{sec:flat-contracts}.
% Consider the example presented on Figure \ref{fig:inter-flat-contracts}, if the
% implementation discussed previously were to be used, we may end up with
% something like this \nickel{((fun x => x) | (Str -> Str)[l]) | C[l]}, where
% \nickel{l} represents the shared state.
% At this point, the intuitive thing to do is to check the contract \nickel{C}, by
% checking if \nickel{((fun x => x) | (Str -> Str)[l]) 0 == 0}.  This will fail,
% since applying a function wrapped in \nickel{Str -> Str} contract to \nickel{0}
% fails negatively.

However, their approach has a major drawback: it is not straightforwardly
compatible with user-defined contracts (introduced in Section
\ref{sec:flat-contracts}). The issue is similar to our initial issue with higher-order
contracts and the naive decomposition: user-defined contracts may apply
functions and thus make a sub-contract of the intersection fail, but this
failure shouldn't always result in raising blame. An example is given on Figure
\ref{fig:inter-flat-contracts}. Decomposing using the shared state approach, we
end up with:

\begin{lstlisting}[language=nickel,frame=none,numbers=none,title={Stateful
decomposition}]
((fun x => x) | (Str -> Str)[l]) | C[l]
\end{lstlisting}

where \nickel{l} represents the shared state.  At this point,
applying the \nickel{C} contract results in evaluating:

\begin{lstlisting}[language=nickel,frame=none,numbers=none]
((fun x => x) | (Str -> Str)[l]) 0 == 0.
\end{lstlisting}

Applying a function wrapped in a \nickel{Str -> Str} contract to \nickel{0}
fails negatively. This is not the expected behavior, since the identity function
does respect semantically both contracts. As opposed to built-in higher-order
contracts, user-defined contracts are black-box from the interpreter's point of
view, and it is thus not obvious how to extend the shared state approach to
handle user-defined contracts. The authors of~\cite{RootCauseOfBlame}
acknowledge this fact: they decide to simply drop user-defined contracts
altogether.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let C = fun f => f 0 == 0 in
let g | (String -> String) @& C
      = fun x => x
\end{lstlisting}
\caption{Intersection and user defined contracts}
\label{fig:inter-flat-contracts}
\end{figure}

Once again, intersection contracts introduce side-effects in the picture. What's
more, these side-effects interact with user-defined contracts in a non-trivial
way, while they are an important feature for validation.
\unsure{(Yann) Should we talk about thiemann here, who do support user-defined
contracts?}
% But this should not have happened, since in the program of Figure
% \ref{fig:inter-flat-contracts} \nickel{g} is never applied to \nickel{0}, in
% fact, it is never applied to anything.  Checking if \nickel{C} has already
% failed, and marking \nickel{String -> String} as failed negatively on \nickel{l}
% is not enough, the contract \nickel{String -> String} should not have been used
% inside the evaluation of \nickel{C}, which adds an extra layer of complexity:
% contracts should be guarded, and execution depends on the shape of the
% surrounding evaluation context.


\subsection*{Challenging the semantics}


Previous points of this section were about how implementing the expected
semantics for union and intersection has a profound impact on the language. Let
us end the section by investigating a different aspect: does the
semantics correspond to the programmer's intuition?

But which semantics? We deemed the exchange law of Figure~\ref{fig:naive-impl}
as "clearly wrong" with respect to overloading. There is nothing wrong per se :
we could chose a semantics for intersections that validate this rule.  However,
the resulting system wouldn't capture overloading, and is arguably not very
interesting nor useful. In~\cite{KeilThiemannUnionIntersection}, the authors
argue for basing the semantics of contracts on union and intersection type
systems, which have a simple and natural definition from which the other
properties follow. This approach makes sense, and has been continued in future
works, and in particular in~\cite{RootCauseOfBlame}.

But even this semantics is no panacea. Figure~\ref{fig:intersection-distribution}
shows an example that intuitively looks like it should succeeed, returning
\nickel{(1, 1)}. However, under the semantics used both
in~\cite{KeilThiemannUnionIntersection} and~\cite{RootCauseOfBlame}, this program
fails with a contract violation.

% Before wrapping up the section, we would like to show that maybe, union and
% intersection contracts are not exactly what we would want them to be.  As stated
% throughout this work, programmers coming from dynamic languages are accustomed
% to perform safety checks (data validation) with great amounts of flexibility and
% the whole power of their language of choice at their disposal.
%
% For instance, a Python programmer may have no problem in checking at runtime,
% that a given variable is an integer if a given flag is not set, as shown in
% Figure \ref{fig:python-assertion}; while a Haskell programmer might close her
% eyes and leave the room instantly.
%
% \begin{figure}[h]
% \begin{lstlisting}[language=python]
% result = 42 if flag else "Disabled"
% ...
% assert (
%   (not flag)
%   or isinstance(result, int)
% )
% \end{lstlisting}
% \caption{Asserting at runtime the type of a variable}
% \label{fig:python-assertion}
% \end{figure}
%
% These expectations are not really met by how unions and intersections
% contracts are supposed to work.
% For example, consider the Nickel code shown on Figure
% \ref{fig:intersection-distrbution}, at first sight, this code should
% complete execution successfully, returning \nickel{(1, 1)},
% however, under both the Keil and Thiemann, as well as the
% Williams, Morris, and Wadler works, this program will fail, with a violation
% of the contract imposed to \nickel{g}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f = fun x y => x in
let g = f | (Num -> Num -> Num)
            @& (Num -> Bool -> Num) in
let h = g 1 in
(h 1, h true)
\end{lstlisting}
\caption{Intersection contracts don't distribute}
\label{fig:intersection-distribution}
\end{figure}

This discrepancy is inherent to the chosen semantics .  When applying a function
with an intersection contract, only one component of the intersection must be
selected for the function. The actual choice of component may be delayed to
later, but the point is that it must be the same across all usages. In
Figure~\ref{fig:intersection-distribution}, the contract for \nickel{h} can in
consequence be either \nickel{Num -> Num} or \nickel{Bool -> Num}, but not both.
This is a manifestation of the following more general defect: the distributivity
law given in Figure~\ref{fig:distributivity-law} is not valid in the semantics
given in~\cite{KeilThiemannUnionIntersection}, while it is both sound to add and
intuitive.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
A -> B @& A -> C (*@ $\simeq$ @*) A -> (B @& C)
\end{lstlisting}
\caption{Distributivity law}
\label{fig:distributivity-law}
\end{figure}

Curiously, union and intersection type systems, on which
\cite{KeilThiemannUnionIntersection} are basing their semantics on, don't
exhibit this property. Subtyping allows to correctly type check a term like
\nickel{g 1} as both \nickel{Num -> Num} as well as
\nickel{Bool -> Num}, and then deducing that \nickel{g 1}
can be given the type \nickel{Num -> Num @& Bool -> Num}.
\unsure{(Yann) I just reworked the wording, but I'm not totally sold on the
argument}

\section{Issues in concrete restrictions from the literature}
\label{sec:issues-literature}
\info{The various papers and the tradeoffs they make}

\unsure{WARNING: what is below is being reworked by Yann}

The existing work that previously researched and implemented
union and intersection
as dynamic checks have, in our eyes, different shortcomings
that makes them suboptimal solutions.
In this section, we informally present those issues,
starting with the foundational paper by Keil and Thiemann
\cite{KeilThiemannUnionIntersection}, then following to a recent
work by Williams, Morris, and Wadler \cite{RootCauseOfBlame}, and
finally going over some similar contracts available in the Racket
programming language.

\subsection*{Keil and Thiemann}
\label{sec:keil-thiemann}
\unsure{Subsection title?}
Keil and Thiemann noticed that, since union contracts should share information between
different application contexts, while intersection contracts should behave
independently between each application context, the system becomes much
simpler if every contract gets transformed into a union of intersections
of other contracts, by using the common De Morgan laws,
and then eagerly opening up unions, but postponing intersection
contracts as much as possible.
\todo{This assumes the difficulty has been previously explained}

For instance, if someone were to wrap a value \nickel{x}
in a contract as shown on the Original code snippet on Figure
\ref{fig:kt-contract-transf}, then, before actually executing that
contract, it would get transformed, and intersections would
be pushed inside the unions, as can be seen on the Transformed
code snippet on the same figure.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Original]
x | A @& (B @| C)
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Transformed]
x | (A @& B) | (A @& C)
\end{lstlisting}
\caption{Contract transformation performed by the Keil and
Thiemann work}
\label{fig:kt-contract-transf}
\end{figure}

This straightforward idea makes composing the Keil and Thiemann
solution with other existing systems more difficult; in the words
of Williams, Morris, and Wadler (see Section~\ref{sec:will-morr-wadl}):
``(\ldots) the monitoring semantics for contracts of intersection and union types given by Keil
and Thiemann are not uniform. (\ldots) If uniformity helps composition, then
special cases can hinder composition.''\cite{RootCauseOfBlame}.
\info{(Yann) Does
it also make it less efficient? If $(A \cap B)$ fails because of $B$, their
development causes to recheck the contract $A$ that has been duplicated?}
And it also could harm performance, or at least complicate an implementation,
since some sharing mechanism should be used to avoid checking the same contract,
over the same value, multiple times, exemplified by contract \nickel{A} on
Figure \ref{fig:kt-contract-transf}, that gets duplicated.
\unsure{Arnaud says: this whole
section is too abstract give concrete code and explain what goes
wrong. It's fine to give code in Nickel syntax}

Another difficult issue Keil and Thiemann were able to solve, is the
fact that user defined contracts and intersection do not usually play nice
together, as shown on Section \ref{sec:flat-and-inter}.
They provide two different sets of rules for their calculus,
the first one is non deterministic, and its purpose is to provide
semantics that are simple to understand.
With these rules, the interaction between user defined contracts and
intersections becomes much simpler, since they are able to check
both sides of an intersection on separate threads.
This allows them to be sure that contracts from one branch of the intersection
won't get blamed while executing the other branch, and vice versa.

As an example, consider the programs shown on Figure
\ref{fig:kt-non-deterministic}, if the Original program
gets executed, it will spawn two instances of said program,
one with the first branch of the intersection (\nickel{3 | Num}),
and the other one with the second branch (\nickel{3 | Positive}),
and these will get joined once they reach an equal point, in this case
it will be \nickel{3}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Original]
3 | Num @& Positive
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=First Program]
3 | Num
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Second Program]
3 | Positive
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Joined Program]
3
\end{lstlisting}
\caption{Non deterministic intersection contract opening}
\label{fig:kt-non-deterministic}
\end{figure}

The second set of rules is deterministic, and it is intended
to be simpler to implement.
However, this second set needs to perform operations
on the evaluation context, to decide whether or not to evaluate
a given contract.
\footnote{You can check more on this topic on Section 5.1 of
\cite{KeilThiemannUnionIntersection}}
For instance, in the program presented on Figure \ref{fig:inter-flat-contracts},
when using the value \nickel{(fun x => x) | Str -> Str)}
inside the execution of contract \nickel{C}, and applying it to \nickel{0},
the contract runtime would check the context of execution and it would
deduce that contract \nickel{Str -> Str} does not apply in this case,
skipping it.

We see two problems here, a minor one is the fact that the two
different semantics defined for the calculus are really far apart
one from the other, both on the strategies used for contract resolution,
as well as on the complexity levels.
\resolved{(Yann) Is it really a
    problem per se? It is common thing to do (a nice declarative system
    for proofs and an algorithmic one for implementation, proved equivalent).
    Maybe the point is that the algorithmic system is way more complex than the
declarative one
(Teo) reworded}.
A second, major one,
is the dependency added over the evaluation context, since, again,
it makes composing this, with other features desired on programming languages,
difficult, or even impossible.
\resolved{(Yann) I think we need to substantiate this claim. If this
context dependency explains why CSE is invalid, maybe have a little example?
(Teo) I removed it, I don't think there's an example, mainly since
this context dependency is not part of the language. I do think it complicates
implementation of said feature}
\todo{(Yann) TODO: see if there's a low hanging complexity
    argument we can make (like it's quadratic in the number of open contracts or
whatever)}

\subsection*{Williams, Morris, and Wadler}
\label{sec:will-morr-wadl}
\unsure{Subsection title?}

Williams, Morris, and Wadler, take a different approach on user defined contracts,
they are completely forbidden in their system, explicitly to not encounter
the previously mentioned issue.
This restriction goes against what is usually expected from dynamic checks:
validation of data, and not just inclusion on types.

On top of that, a fundamental problem arises on said paper,
symptom of the difficulty of establishing good enough, and yet
simple semantics for union and intersection dynamic checks.
One of their main results, is the fact that their calculus obeys
all of their expected monitoring properties for higher ordered, union
and intersection contracts.
However, one of these properties states the following:

\begin{figure}[h]
$$ K \in \llbracket A \cap B \rrbracket^-~if~K \in \llbracket A \rrbracket^- \lor K \in \llbracket B \rrbracket^- $$
\caption{Sound monitoring property for intersection from Williams, Morris, and Wadler.}
\label{fig:wmw-semantics}
\end{figure}

Which means that a continuation $K$ complies negatively with an
intersection of $A$ and $B$ if it complies negatively with at least one of these.
Or, less formally, that if you have a program that is missing a value at a given point,
you can put a value wrapped with a contract stating $A \cap B$,
and expect not to get a negative violation of that contract,
if you can either put a value
wrapped with $A$, or a value wrapped with $B$.

Altough this is true, it's a weaker statement of what we'd like to have,
consider the two contexts presented on Figure \ref{fig:valid-contexts},
the first one is a valid context for a \nickel{Num -> Num} function,
that is, you could replace the $\square$ by some function wrapped in a
\nickel{Num -> Num} contract, and the context will not violate it.
Similarly, the second context from the same figure is a valid
\nickel{Bool -> Bool} context.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=\nickel{Num -> Num} context]
(*@$\square$@*) 3
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=\nickel{Bool -> Bool} context]
(*@$\square$@*) true
\end{lstlisting}
\caption{Two different contexts in Nickel}
\label{fig:valid-contexts}
\end{figure}

Next, we can combine these two contexts into one, that essentially
has one single missing value, that will be used independently in both contexts
from Figure \ref{fig:valid-contexts}, as shown on Figure \ref{fig:invalid-context}.
This context is not a valid \nickel{Num -> Num} context, since it will apply
the value put on $\square$ (through \nickel{f}) to a non \nickel{Num} (\nickel{true}).
In a similar way, it is not a valid \nickel{Bool -> Bool} context either.
Therefore, according to the semantics from the Williams, Morris, and Wadler paper, as
shown on Figure \ref{fig:wmw-semantics}, it is not a valid
\nickel{Num -> Num @& Bool -> Bool} context.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f = (*@$\square$@*) in
(f 3, f true)
\end{lstlisting}
\caption{Invalid \nickel{Num -> Num @& Bool -> Bool} context,
combining contexts from Figure \ref{fig:valid-contexts}}
\label{fig:invalid-context}
\end{figure}

However, both our intuition, as the most common use case of intersections
(that is, overloading), tells us that this should work.
While this problem does not invalidate their work (in fact, the system they present
handles these cases correctly), it shows that existing research is still not on
good shape to handle the growing usecases being developed for
unions and intersections around dynamic languages.

% $$ K ::= Id | K \bullet \square N | K \bullet V \square | K \bullet \square @^pA  $$

% Keil and Thiemann did noticed this problem, and their contract satisfaction
% rules only apply to elimination context, a particular kind of context
% where the hole is either being applied to an argument
% ($\square N$) or is used as an argument for a primitive
% operation ($O(\overrightarrow{\text{V}}, \square, \overrightarrow{\text{N}})$).



% K ::= Id | K   N | K  V  | K   @pA
\resolved{(Yann) Maybe adding a concrete example of this (it can be the same term but with
    concrete types like Number and String and simple contexts like application
    to a dumb argument) is sufficient to make the point}

\subsection*{Racket}
\label{sec:racket}


Racket is a language based on Scheme, mainly thought as a language to experiment
with different language desings and ideas. It provides a very complete contract
system\cite{RacketContracts}.

Among those contracts, they provide \racket{and/c} and \racket{or/c} contracts.
These contracts are lightweight versions of intersections and unions, they simply
check that every contract is valid, in the case of \racket{and/c},
and that at least one contract
is valid, in the case of \racket{or/c}.

So, for instance, the usual usecase of intersection to encode bounded overloading
does not work on Racket. Take a look at the next example, the function
\racket{overload} should accept a call like \racket{(overload 3)}, but it fails
since 3 is not a valid \racket{string?}.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract overload
(and/c (-> number? number?)
       (-> string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{Non working function overloading on Racket.}

\end{figure}

Even worst, the \racket{or/c} contract doesn't allow to have multiple higher order
contracts that could (potentially) apply to a function, these have to be
differentiated by first order markers.
For instance, the code on Figure~\ref{code:racket:or/c:working}
would correctly allow only to call
\racket{united} with a \racket{number?},
and it can make this distinction since it knows that
\racket{(lambda (x) x)} can not be a function that takes 2 parameters.
However, the code on Figure~\ref{code:racket:or/c:non-working} would fail
before running, since the \racket{or/c} contract is unable to know
which of the two function contracts to use.
Ideally, this last example should just behave as wrapping
the function with the \racket{(-> even? even?)} contract.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract united
(or/c (-> number? number?)
      (-> string? string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{Working \racket{or/c} example on Racket.}
\label{code:racket:or/c:working}

\end{figure}

\begin{figure}[h]

\begin{lstlisting}[language=lisp]
(define/contract united
(or/c (-> number? number?)
      (-> even? even?))
(lambda (x) x))
\end{lstlisting}
\caption{Non working \racket{or/c} example on Racket.}
\label{code:racket:or/c:non-working}

\end{figure}


\unsure{This section is overall a bit hard to follow. I
  think I've figured out what it means, but it needs more love. Also
  give an example which doesn't work and one that does for or/c.}

\subsubsection*{case->}

Racket does provide an alternative for overloading methods, called the
\racket{case->} contract, however, this overloading of methods only
works over contracts of functions with different amount of parameters.
It's a good alternative to allow limited overloading of functions.
As an example, consider the following non failing piece of code, and
try to understand how Racket can decide, at each application,
which function contract to use.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract overcase
  (case-> (-> string? string?)
          (-> number? number? number?)
          )
  (lambda (x [y 0]) (if (number? x)
                   (+ x y)
                   x)))

(overcase 1 2)

(overcase "hello")
\end{lstlisting}
\end{figure}

Even if Racket's intent is not to implement union and intersection
dynamic checks, they do provide contracts that are, in some sense,
simplified versions of those.
In our eyes, Racket has accepted the difficulty of correctly and practically
combine union, intersection, and higher order contracts, and has choose
to prioritise the highe order ones.



\section{Related work}
\label{sec:related-work}
\info{Including a mention of statically typed systems with union}



\section{Conclusion}
\label{sec:conclusion}

The design and implementation of programming languages is a challenging task. It
is a delicate exercise to balance complexity, expressiveness, efficiency and
user experience all together. Unfortunately for designers, a language cannot
usually be reduced to a simple sum of small independent features. They are
rather composed of a lot of moving parts that interact in unexpected ways. The
more a language grows, the more any new addition has to be weighted carefully,
as it has the potential to interact with any of the existing features.

Part of recent developments revolve around mixing static typing and dynamic
typing via gradual typing, in order to get the best of both worlds. Contracts
(or casts in the gradual typing terminology) are crucial to this endeavour by
allowing for a safe interaction between typed and untyped code. But we also made
a case that contracts are interesting in themselves in a fully dynamically typed
language (and even in a fully statically typed language).  Contracts are a
precious idiom for data validation or to check pre- and post-condition that
would be hard to ensure statically. In spirit, contracts are similar to
assertions, but they are part of a principled framework, they are composable,
they have good error reporting and they are integrated as a language feature. In
particular, contracts natively handles higher-order functions and built-in data
structures. This makes them an great candidate for integration in the Nickel
configuration language.

This is only the beginning of the story. A language designer then has to choose
what contract combinators to provide among a number of possibilities: there is
the standard package including higher-order function contracts, record contracts
and list contracts.  Then, one could add polymorphic
contacts~\cite{BlameForAll}, dependent function
contracts~\cite{DependentContracts}, and so on. For validation purpose, union and
intersection contracts are really appealing. Unions have a intuitive
interpretation as modeling alternatives and thus appear implicitly or explicitly
in a lot of data structures.

Alas, the implementation of union and intersection contracts is not as simple as
it first appears. In conjunction with higher-order contracts, or even just basic
contracts in a lazy language, they behave in a way that is reminiscent of
side-effects. These behaviors were, for most of them, already known: we do not
claim their discovery. However, as language implementers, we have made an actual
attempt at including them in a concrete language. We exposed what, in our
opinion, are the most important barriers and their impact on the rest of the
language. Even in a pure setting, union and intersection contracts break the
equivalence between call-by-name and call-by-value, and can consequently prevent
optimizations. There are discrepancies between the expected and actual semantics
that make some behaviors unintuitive. Their implementation is a non-trivial
change that contaminates the evaluation of all other contracts, and the
performance penalty is not obvious to assess.

To conclude, let us make clear that we do not think union and intersection
contracts are fundamentally broken, that they can not be implemented correctly,
or that they do not bear any value (quite the contrary). They may still make
sense to have in a language, and some apparent difficulties in the
implementation could be lifted some day. But as often, there are gaps between
the theoretical foundation, a proof-of-concept, a prototype, and the integration
in an actual language. We hope that our attempt may serve as a cautionary tale:
for union and intersection contracts, these gaps might be quite large in places.

\bibliography{nickel}
\end{document}

% LocalWords:  Felleisen JSON TOML YAML templating Jsonnet Dhall MyPy
% LocalWords:  Kubernetes DevOps natively nixpkgs disjunctions
% LocalWords:  TypeScript
