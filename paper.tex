\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\usepackage{amssymb}
\usepackage{mathtools,amsmath,amsfonts,amsxtra,amsthm,mathrsfs,mathpartir}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\usepackage{varioref}
\usepackage{verbatim,comment}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{url}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}

\definecolor{OliveGreen}{RGB}{128,128,0}
%%%%%%%%%%%%%%%%% Editing marks %%%%%%%%%%%%%%%%%

  % TOGGLE ME to turn off all the commentary:
  \InputIfFileExists{no-editing-marks}{
    \def\noeditingmarks{}
  }

  \usepackage{xargs}
  \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
  % ^^ Need for pgfsyspdfmark apparently?
  \ifx\noeditingmarks\undefined
      \setlength{\marginparwidth}{1.2cm} % A size that matches the new PACMPL format
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
      \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
      \newenvironment{alt}{\color{red}}{}

      \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
      \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
      \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
      \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
      \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
  \else
  %    \newcommand{\Red}[1]{#1}
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{#1}
      \newcommand{\note}[1]{}
      \newenvironment{alt}{}{}
  %    \renewcommand\todo[2]{}
      \newcommand{\unsure}[2][1=]{}
      \newcommand{\info}[2][1=]{}
      \newcommand{\change}[2]{}
      \newcommand{\inconsistent}[2]{}
      \newcommand{\critical}[2]{}
      \newcommand{\improvement}[1]{}
      \newcommand{\resolved}[2]{}
  \fi

%%%%%%%%%%%%%%%%% /Editing marks %%%%%%%%%%%%%%%%%

%%%%%%%%%%% LST listing confinguraiton %%%%%%%%%%%

\lstdefinelanguage{nickel}{
    keywords=[1]{
      if,
      then,
      else,
      switch,
    },
    keywords=[2]{
      let,
      rec,
      fun,
      in
    },
    keywords=[3]{
      forall,
    },
    keywordsprefix=\#,
    keywords=[4]{
      true,
      false,
      null
    },
    keywords=[5]{
      doc,
      default,
    },
    sensitive=true, % keywords are case-sensitive
    morecomment=[l]{//}, % l is for line comment
    morecomment=**[is][\color{gray}]{\$}{\$},
    morestring=[b]", % defines that strings are enclosed in double quotes
    morestring=[s]{m\#"}{"\#m},
    moredelim=[is][\color{gray}]{\$}{\$},
    literate=
        *{->}{$\rightarrow$}1
        {...}{\ldots}1
        {@&}{$\cap$}1
        {@|}{$\cup$}1
        {=>}{$\Rightarrow$}1
        {>=}{$\geq$}1
        {<=}{$\leq$}1
} %

% Copied from https://hal.inria.fr/hal-01140459/file/racket.inc.tex
\lstdefinelanguage{racket} {
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    define-context, define-controller, Integer, Boolean, get, when-required, when-provided,
    maybe_publish, require, submod, or/c, and/c, ->, \#\%module-begin,
    always_publish, with-syntax, define-struct/contract, syntax-case,
    define/contract,
    let-values, let*-values,
    module, provide,
    and, or, not, delay, force,
    \#`, \#',
    \#lang, implement, begin-for-syntax, rename-out,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsoletter={',`,-,/,>,<,\#,\%},
  morecomment=[l]{;},
%  literate={lambda}{{\lambdaup}}1, % lambda -- look at https://tex.stackexchange.com/questions/119879/math-symbols-in-tt-font
  moredelim=**[is][\color{light-gray}]{<<@<<}{>>@>>},
  moredelim=**[is][\itshape\color{OliveGreen}]{<<;<<}{>>;>>},
  morecomment=[s]{\#|}{|\#},
  sensitive=true,
}

\lstset{
  language={nickel},
  basicstyle=\small\ttfamily, % Global Code Style
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=2, % number of spaces indented when discovering a tab
  columns=fixed, % make all characters equal width
  keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
  showstringspaces=false, % lets spaces in strings appear as real spaces
  breaklines=true, % wrap lines if they don't fit
  frame=trbl, % draw a frame at the top, right, left and bottom of the listing
  frameround=tttt, % make the frame round at all four corners
  framesep=4pt, % quarter circle size of the round corners
  numbers=left, % show line numbers at the left
  numberstyle=\tiny\ttfamily, % style of the line numbers
  escapeinside={(*@}{@*)} % escape sequence to insert latex
  % commentstyle=\color{dark-grey}, % style of comments
  % keywordstyle=[1]\color{blue-portage}, % style of keywords
  % keywordstyle=[2]\color{orange-vivid-tangerine}, % style of keywords
  % keywordstyle=[3]\color{blue-portage}, % style of keywords
  % keywordstyle=[4]\color{green-pea}, % style of keywords
  % keywordstyle=[5]\color{pink-froly}, % style of keywords
  % stringstyle=\color{blue-marguerite}, % style of strings
}

\lstset{
  escapeinside={(*@}{@*)} % escape sequence to insert latex
}
\newcommand{\nickel}[1]{\lstinline[language=nickel]{#1}}
\newcommand{\racket}[1]{\lstinline[language=racket]{#1}}

\bibliographystyle{ACM-Reference-Format}

\begin{abstract}
This paper reports an attempt to incorporate union and intersection types in
Nickel, a configuration programming language with a gradual type system and
first-class contracts. While the end result looks appealing, it turns out the
concrete impact on both the design and the implementation of the language is
unexpectedly high. We review the issues raised in particular by the
implementation of contracts for unions and intersections, and why we think the
cost ends up too high for the benefit. We conclude by suggesting different leads
to represent and type unions.
\end{abstract}


\title{Contracts for unions and intersections are hard for Nickel}
\author{Teodoro Freund}
\affiliation{
  \institution{Universidad de Buenos Aires}
  \city{Buenos Aires}
  \country{Argentina}
}
\email{tfreund95@gmail.com}

\author{Yann Hamdaoui}
\affiliation{
  \institution{Tweag}
  \city{Paris}
  \country{France}
}
\email{yann.hamdaoui@tweag.io}
\author{Arnaud Spiwack}
\affiliation{
  \institution{Tweag}
  \city{Paris}
  \country{France}
}
\email{arnaud.spiwack@tweag.io}

\begin{document}

\maketitle

\unsure{TODO: CCS classification; Keywords}
\section{Introduction}
\label{sec:intro}
\info{Goals of the paper: position paper: unions/intersections nice in
theory problematic in practice. In particular non-orthogonal with the
rest of the features of your language.}

Union types, meaning a type \nickel{A @| B} containing values which
belong either to a type \nickel{A} or \nickel{B}, are a popular tool
when adding a static types to a dynamic language. In particular, both
TypeScript~\cite{TypeScriptUnions} and MyPy~\cite{MyPyOptional}, use
union typed to model the frequent practice to use the value
\lstinline{null} (\lstinline{None} in Python) to represent an absent
optional value. This is why the gradual typing literature, concerned
with formalising the interplay between static and dynamic type
systems, has been quite interested in union
types~\cite{RootCauseOfBlame,KeilThiemannUnionIntersection}.

On the other hand, unions are not a common feature of static type
systems, mostly because they are quite difficult to verify
statically. So unions are really only worth it in gradually typed
language where they formalise existing dynamically typed patterns. On
the other hand, surely, for dynamic tests, unions are really easy: it
is simply the Boolean disjunctions of two tests.

Unfortunately, as we document in this article, as soon as you extend
dynamic checks to \emph{contracts}~\cite{FindlerFelleisenHOContracts},
unions become actually pretty difficult, and threaten desirable
properties of your language.

\subsection*{Configuration languages}

To motivate contracts and the problem caused by unions, let's make a
detour through configuration languages.
%
A configuration language is a language concerned with describing the
configuration of an application. In traditional configuration
languages, such as YAML, TOML, or JSON, the configuration is fully,
and explicitly, spelt out.

However, with the advent of DevOps, configurations have been extended
to describe the entire state of a computer, or even a fleet of
computers. For instance, with Kubernetes you need to configure a large
fleet of (possibly replicated) docker containers. To describe this
sort of configurations, you really want to be able to re-use and
abstract parts of the configuration, like traditional programming
languages do. To meet this need, languages such as Cue~\cite{?},
Dhall~\cite{?}, Jsonnet~\cite{?}, or Nickel~\cite{NickelRepo}, where
configurations are generated rather than spelt out, were created.

Another example is continuous integration systems: it's fairly typical
to need a matrix of jobs, wherein the same tests are run on different
infrastructures, or with different versions of a compiler. Traditional
configuration would have you copy the same steps for each
infrastructure. This is tedious, hard to maintain, and error
prone. It's much better, instead, to write the steps once, and
instantiate them for each infrastructure. Continuous integration
systems typically do this using a templating system layered on top of
YAML. Each of the configuration-generating languages above allow such
job-matrix definition natively.

\subsection*{Nickel}

In this article, we will use the Nickel language~\cite{NickelRepo} as
illustration and motivation. At its core, Nickel is the JSON data
model, that is dictionaries (written \nickel{\{field1 = value1, ...,
  fieldn = valuen\}}) and arrays (\nickel{[x1, ..., xn]}), augmented
with functions (\nickel{fun arg1 ... argn => body}) and
let-definitions (\nickel{let id = value in exp}).\unsure{Arnaud: this
  paragraph looks kind of bad, maybe it'll be better to put each
  syntax entry in an enumeration, we will see if there is still room
  for this}

A Nickel configuration is then evaluated to an explicit configuration,
\emph{e.g.}  in JSON, which can then be consumed by an
application. Therefore a design constraint of Nickel is any Nickel
data must have a straightforward interpretation in JSON.

\subsection*{Contracts}

A useful feature of a configuration language is to provide facilities
for schema validation. That is, help answer questions like: does our
configuration have all the required fields? does the \nickel{url} field indeed
contains a URL?

These are inherently dynamic questions, as they are all questions
about the evaluated configuration. To this effect, Nickel lets us
annotate any expression with a dynamic schema check: \nickel{exp |
  C}. There is also syntactic sugar to annotate definitions:
\nickel{let id | C = value in exp} stands for \nickel{let id = (value
  | C) in exp}.\unsure{This point used to be made, to we want to
  reinsert it? However, Nickel programs are of a special kind: they are usually
simple, terminating programs that run on fixed inputs. Correctness errors will
show up at evaluation anyway, or will not matter (dead code).}

Let us pause for a moment and consider the following: it is Nickel's
ambition to be able to manipulate configurations like Nixpkgs. With
over 50\,000 packages, is one of the largest repository of software
packages in existence~\cite{repology}. Concretely, Nixpkgs is a
dictionary mapping packages to build recipes. That is, a massive,
over-50\,000-key-value-pair wide dictionary. It is absolutely out of the
question to evaluate the entirety of this dictionary every time one
needs to install 10 new packages: this would result in a painfully
slow experience.

To be able to support such large dictionaries, Nickel's dictionaries
are \emph{lazy}, that is, the values are only evaluated when
explicitly required. For instance, when writing
\hbox{\nickel{nixpkgs.hello},} only the \nickel{hello} package gets
evaluated.

But let's consider now writing something like \nickel{nixpkgs |
  packages}, to guarantee that all the packages conform to the desired
schema. If this were a simple Boolean test, it would have to evaluate
all 50\,000 package to check their validity, hence breaking the
laziness of dictionaries. Do we have to choose between laziness and
schema validation? Fortunately, we don't! Enter
\emph{contracts}~\cite{FindlerFelleisenHOContracts}: dynamic check
which can be partially delayed, yet errors can be reported
accurately. Contracts can respect laziness of dictionaries, and they
can be use to add schema validation to functions as well (in fact
functions were the original motivation for contracts).

There is no Boolean function which can check that a value has type
\nickel{Str -> Str}. Instead, a contract for \nickel{Str -> Str}
checks for each call of the function whether
\begin{enumerate}
\item the argument has type \nickel{Str}, otherwise the caller of the
  function is faulty
\item if so, that the returned value has type \nickel{Str}, otherwise
  the implementation of the function is faulty
\end{enumerate}

Like in the case of lazy dictionaries, the checks are delayed.
Contracts keeps track of whether the caller or the implementation is
at fault for a violation, hence it can report precise error
messages. Compare Figure~\ref{fig:contract-reporting-wo} and
Figure~\ref{fig:contract-reporting-w}: in
Figure~\ref{fig:contract-reporting-wo} an error is reported inside the
\nickel{catHosts} function, but \nickel{catHosts} is, in fact,
correct, as is made clear by Figure~\ref{fig:contract-reporting-wo},
where \nickel{catHosts} is decorated with the \nickel{Str -> Str}
contract, and correctly reports that the caller failed to call
\nickel{catHosts} with a string argument.

\begin{figure*}
  \centering
  \begin{subfigure}[b]{0.48\linewidth}
    \begin{lstlisting}[language=nickel]
let catHosts = fun last =>
  let hosts = ["foo.com", "bar.org"] in
  lists.fold (fun val acc => val ++ "," ++ acc) hosts last in

let makeHost = fun server ext =>
  server ++ "." ++ ext in

catHosts (makeHost "google")
\end{lstlisting}

    \begin{lstlisting}[frame=none,numbers=none, basicstyle=\footnotesize\ttfamily]
error: Type error
3 | [(*@{\ldots}@*)] "," ++ acc) hosts last in
  |            ^^^
  | This expression has type Fun,
  | but Str was expected
4 |
5 | let mkHost = fun server ext => [(*@{\ldots}@*)] in
  |              -----------------------
  |              evaluated to this
  = ++, 2nd argument
\end{lstlisting}
    \caption{Error reporting without contract}
    \label{fig:contract-reporting-wo}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.48\linewidth}
    \begin{lstlisting}[language=nickel]
let catHosts | Str -> Str = fun last =>
  [(*@{\ldots}@*)]
\end{lstlisting}
\vspace{10ex}
    \begin{lstlisting}[frame=none,numbers=none, basicstyle=\footnotesize\ttfamily]
error: Blame error: contract broken by the caller.
  |  Str -> Str
  |  --- expected type of the argument [(*@{\ldots}@*)]
[(*@{\ldots}@*)]
1 | let catHosts | Str -> Str = fun last =>
  |                ^^^^^^^^^^ bound here
[(*@{\ldots}@*)]
6 | catHosts (makeHost "google")
  | --------------------------- (2) calling <func>
    \end{lstlisting}
    \caption{Error reporting with contract}
    \label{fig:contract-reporting-w}
  \end{subfigure}
  \caption{Contracts improve error messages}
\end{figure*}

\rule{3cm}{3pt}

\unsure{Arnaud: What's below this point in the introduction is being reworked}

\subsection*{Correct programs \& valid data}

With respect to
validation, traditional types are too limited. Validation commonly involves
checking requirements such as being a valid port number or a valid URL which
are, while not technically impossible, really hard to check statically.

\subsection*{Contracts}

The examples of Figure~\ref{fig:contract-reporting-wo} and
Figure~\ref{fig:contract-reporting-w} are about correctness. For validation, one
of the main appeals of Nickel in our opinion is the ability to write a simple
validation function for, say, a port number, and have it immediately available
to construct other contracts by writing simple type-like expressions.  Another
example is given in Figure~\ref{fig:contract-composition}. The first line
defines a port contract from a predicate and use it in the definition of a
larger \lstinline+Configuration+ record contract. The \lstinline+Configuration+
contract checks that a value is a record with the following shape: it must have
a \lstinline+port+ field obeying the \lstinline+Port+ contract, and a
\lstinline+host+ field obeying a \lstinline+Host+ contract. It plays the role of
a \emph{schema} used to validate the final data, which is exactly what we were
looking for in the previous section. Not only it plays the role of a schema, but
it also \emph{looks} like one, as opposed to the corresponding plain validation
function. The \lstinline+|+ operator entails that a value respects a contract,
akin to \lstinline+:+ for types. We assume that a \lstinline+Host+ contract has
been defined in a similar way. \resolved{What's missing in this section is an
example of how contracts differ from standard dynamic type checking on some
function. Namely, the quality of error messages.}

\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel]
let Port = contracts.fromPred (fun value =>
  builtins.isNum value && value % 1 == 0
  && value >= 0 && value <= 65353) in
let Configuration = {
  host | Host,
  port | Port,
} in
{host = "nixos.org", port = 80}
| Configuration
\end{lstlisting}
  \end{center}
\caption{Contract composition}
\label{fig:contract-composition}
\end{figure}

Contracts have another perk: they correspond to the type casts of gradual
typing, a discipline for mixing static and dynamic typing in the same language.
As such, they are a precious ingredient for handling the interaction between 
statically typed and dynamically typed code. While we focused on the writing of
configuration, Nickel is a proper programming language that is also designed to
write generic and reusable library code. There, the typing trade-off is
different, and static typing is more adapted. Nickel has a gradual type system,
which is yet another argument for having contracts. Let us end this section by
stressing the following points:
\begin{itemize}
    \item \textbf{Even in a purely dynamically typed language, contracts are an
        appealing feature for validation and correctness}. The gradual typing
        part enters the general picture but is out of the scope of this paper.
    \item \textbf{User-defined contracts are essential for validation}. Some
        contract systems (as the one of~\cite{RootCauseOfBlame}, that will be
        extensively discussed later in the paper) do not feature user-defined
        contracts.  Rather, a fixed set of built-in contracts such as
        \nickel{Num} or \nickel{Str} are provided, very much like base
        types. The absence of user-defined contracts is understandable when
        using contracts as a dynamic typing discipline for correctness. But a
        system without user-defined contracts is limited in the same way as
        static typing with respect to validation.
\end{itemize}

\subsection*{Structure of this paper}
Section~\ref{sec:intro} introduced the perspective of designing a configuration
language. We presented the concept of contracts and detailed why contracts are
particularly fitted for a configuration language, and more generally for data
validation or program correctness in a dynamically typed language. The rest of
the paper is structured as follows:
\begin{itemize}
    \item Section~\ref{sec:feat-lang} outlines various common features of
        programming languages that may interact in a bad way with union and
        intersection contracts.
    \item Section~\ref{sec:union-inter} introduces unions and intersections and
        lists the possible motivations for adding them to a language.
    \item Section~\ref{sec:issues-sem} studies intrinsic difficulties one may
        encounter when trying to implement union and intersection contracts in
        practice.
    \item Section~\ref{sec:issues-literature} presents the shortcomings found in
        existing attempts to solve said difficulties.
    \item Section~\ref{sec:related-work} provides some related work.
\end{itemize}

Section~\ref{sec:conclusion} concludes the paper.

\newpage

\section{Features of languages}
\label{sec:feat-lang}
\info{Zoology of various features that we will eventually show
  conflict with this or that property or implementation of union and
  intersection. Including user-define contracts.}

Programming language research no longer lives on the abstract world
of ideal surfaces.
Every addition needs to be compatible with years of research
and development, and this is hard.
Success was unavoidable.

In this section we briefly introduce some aspects of real world
programming languages that will cause trouble while interacting
with union and intersection dynamic checks.

\subsection*{User defined contracts}
\label{sec:flat-contracts}

User defined contracts, sometimes called flat contracts, are a particular
kind of contract that behaves similar to an assertion, and whose
main utility is to apply some arbitrary predicate (as arbitrary as the
host language allows it) to a value; if the predicate evaluates to
true, the contract passes, otherwise it fails.

For instance, the contract \nickel{Even} shown on Figure
\ref{fig:contract-higher-order} is a user defined contract, defined
by taking the value that needs to be checked, and validating
that is both a number and that the remainder of dividing it by 2
is 0.
And then, as seen on the same figure, we can use it to check that a function always
returns an \nickel{Int} when applied to an \nickel{Even}.

% \begin{figure}[h]
% \begin{center}
% \begin{lstlisting}[language=nickel]
% let f = fun n => n * 2 @ (Integer -> even)
% \end{lstlisting}
%   \end{center}
% \caption{A function wrapped with a contract stating that it always returns
% an even number}
% \label{fig:num-to-even}
% \end{figure}


Even more interesting, we could come up with a contract that checks that a function
maps \nickel{true} to \nickel{false} and \nickel{false} to \nickel{true}
by applying the function exhaustively and checking its results,
and then use it as a contract for the \nickel{not} function, as can be seen on Figure
\ref{fig:port-contract}.\unsure{These few paragraphs are out of date,
  even more so since Arnaud changed the flat contract example}

\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel]
let Port = contracts.fromPred (fun value =>
  builtins.isNum value && value % 1 == 0
  && value >= 0 && value <= 65353) in
80 | Port
\end{lstlisting}
\end{center}
\caption{A contract for valid ports}
\label{fig:port-contract}
\end{figure}

This type of contracts are present on many different languages,
for instance, the Eiffel programming language\cite{meyer1987eiffel}, the precursor
of the Design by Contract ideals, allows to assert
these kinds of expression as pre- and post-conditions on
functions and as invariants on classes\cite{EiffelDesignByContract}.
\resolved{I (Arnaud) believe Eiffel has this feature as well,
  doesn't it? (Teo) You're right},

% A somewhat newer language, the D programming
% language, allows, among other things, to have invariants on
% classes
% written with flat contracts, that are
% dinamically checked at the frontiers of every public method \cite{DLangContracts}.

The Racket programming language also has a system to work with
contracts, powerful enough to define flat contracts
\footnote{And a gradual typing system
built on top of that, but that goes beyond the scope of this
work.}
, and
to compose them with other kinds of dynamic checks,
like higher order contracts or a lightweight take on union
and intersection contracts\cite{RacketContracts}.

Even if user defined contracts may seem like too permissive, the ability to make
non trivial checks on values (that is, to validate their output) is expected
by programmers on dynamic languages, where testing and runtime
assertions are extremely useful tools for safe programming, and
programmers are accustomed to express complex predicates
over values.


\subsection*{Code manipulation (optimizations)}
\label{sec:optimizations}
\info{Present inlining and CSE as two major code
optimizations.
Purity and immutability as two important factors.}

The performance of modern programs heavily relies on the optimizations performed
by the compiler or the interpreter. Even more so for functional languages, whose
execution model is often far removed from actual processors, causing naive
execution to exhibit unacceptable slowdowns.

One crucial optimization is
inlining (Figure \ref{fig:optimizations-inlining-ex}). Functional programs tend
to make heavy use of functions, and a function call is a costly operation from
the point of view of low-level execution. Inlining eliminates a function
application by directly substituting the function for its definition at compile
time (or before execution, for interpreted language). This is especially
efficient for small functions that are called repeatedly.

\info{I think it's better to use [h] on figures, we can discuss it}
\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elem = fun elt =>
  lists.any (fun x => x == elt) in

let subList = fun l1 l2 =>
  elem (lists.head l1) l2
  && subList (list.tail l1) l2
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let subList = fun l1 l2 =>
  lists.any (fun x => x == (lists.head l1)) l2
  && subList (list.tail l1) l2
\end{lstlisting}
  \end{center}
\caption{Inlining}
\label{fig:optimizations-inlining-ex}
\end{figure}

While inlining expands an expression by substituting a definition for its value,
an opposite transformation is sometimes beneficial, for example when a composite
expression is repeated several times. This causes the same expression to be
wastefully recomputed at each occurrence. Common subexpression elimination (CSE)
consists in introducing a new identifier for this expression and using the
identifier in place of the original occurrences
(Figure \ref{fig:optimizations-cse-ex}), computing the result once and for all.

\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elemAtOrLast = fun index list =>
  if index > lists.length list - 1 then
    lists.elemAt (lists.length list - 1) list
  else
    lists.elemAt index list
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let elemAtOrLast = fun index list =>
  let l = lists.length list - 1 in
  if index > l then
    lists.elemAt l list
  else
    lists.elemAt index list
\end{lstlisting}
  \end{center}
\caption{Common subexpression elimination}
\label{fig:optimizations-cse-ex}
\end{figure}

Beyond CSE, optimizations such as loop-invariant code motion or
let-floating~\cite{letFloating} apply the same principle of extracting out an invariant
\unsure{Was this the inteded citation?}
expression to avoid its recomputation respectively across loop iterations and
function calls.

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let f = fun x => g y (x + 1)
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let g' = g y
let f' = fun x => g' (x + 1)
\end{lstlisting}
  \end{center}
\caption{Let-floating}
\label{fig:optimizations-let-floating-ex}
\end{figure}

For example, take the code of Figure~\ref{fig:optimizations-let-floating-ex}.
The partial application \lstinline+g y+ is recomputed each time \lstinline+f+ is
called. This may be costly, in particular in the presence of contracts: if
\lstinline+y+ is a list for example, and \lstinline+g+ applies a list contract
on it, the cost could be linear in the size of \lstinline+y+. A sensible thing
to do is to factor \lstinline+g y+ out of \lstinline+f+ as in
Figure~\ref{fig:optimizations-let-floating-ex}, which is something a
let-floating transformation could indeed do (given \lstinline+g+ is pure, as
explained below).

The soundness of all these optimizations is tied to the invariance of the
semantics of programs with respect to specific substitutions. Inlining requires
that one can replace the application of a function by its body, which is
basically $\beta$-reduction: as long as the arguments are evaluated following
the language's strategy, it is a valid transformation. On the other hand,
a CSE-like transformation on a term $M$ requires an expansion property of the form

\begin{equation}\label{eq:cbn-expansion}
M[x/N] \simeq let~x~=~N~in~M
\end{equation}

Here, $M[x/N]$ is the substitution of $x$ for $N$ in the term $M$.
\ref{eq:cbn-expansion} has an evident call-by-name flavour, and consequently
fails in general for a call-by-value language with side effects.  Indeed, define
the following function $f$:

\begin{lstlisting}[language=Nickel]
let f x = print "hi";(x+1) in 
\end{lstlisting}

Then:

\begin{lstlisting}[language=Nickel]
(f 1,f 1) (*@ $\not \simeq$ @*) let y = f 1 in (y,y)
\end{lstlisting}

In the example above, the first term prints \nickel{"hi"} two times while the
second term prints it only once. However, \ref{eq:cbn-expansion} does hold for
\emph{pure} terms, that are terms without side-effects. In a pure language, or a
language with effect tracking like Haskell\todo{Cite a different language, or
remove citation}, pure terms can be safely identified for applying
optimizations.

Strikingly, we will see in section~\ref{sec:issues-sem} that the introduction of
unions and intersections can make \ref{eq:cbn-expansion} unsound
\emph{even in a pure setting}, making the optimization of
Figure~\ref{fig:optimizations-let-floating-ex} unsound in general.

\unsure{Should we tease already here that unions and intersections break this
even for pure terms?}

\subsection*{Lazyness}
\todo{Lazyness does not appear on sec 4, if we don't put somethign there, I'd remove it}
Evaluation strategies relates to the evaluation of the expression bound to
identifiers. Expressions are bound by assignments (e.g. let bindings in
Nickel), or by function applications (arguments are bound to parameters). We
will use Figure~\ref{} as a working example.

The eager strategy consists in evaluating right away a bound value before
storing it in an identifier. If an identifier is not used, this leads to
unnecessary work: in Figure~\ref{}, the expression \nickel{fibonacci 100} would
be computed although it is never used. The lazy strategy, on the other hand,
only evaluates expression if they are needed. In the lazy model, bound
expressions are stored as in their current unevaluated form, also called a
\emph{thunk}. Thunks are only evaluated at their first usage, and their value is
memoized for future usages.

The eager strategy has been chosen in the vast majority of languages: while
theoretically less efficient, it is simpler to implement and more predictable
for the programmer. Also, lazy evaluation can occur performance overhead and
memory leaks in unexpected ways. While eager evaluation is the default, some
languages however offer a form of lazy evaluation, either as an opt-in option
(e.g. Ocaml and ReScript), or by default for specific primitives types such as
list (e.g.  Swift and Perl6). The most notable lazy language is Haskell
(and its web avatar PureScript). Although rare in general purpose languages,
lazy evaluation is more widespread in the configuration space: the configuration
languages Dhall, CUE and Jsonnet also implements full lazy evaluation. So are
the Nix language, which inspired Nickel, and Nickel itself.

\newpage

\section{Union \& intersection}
\label{sec:union-inter}
\info{What are they, what are they used for.}
\resolved{Since nickel uses | for contract application, I'd move unions
to some other symbol.
I think the best option is to move to $\cap / \cup$}

\subsection*{Unions}
Unions are fundamental building blocks of programs. A union holds a value whose
shape is known to be in a fixed set of alternatives: for example, a value that
can be either a boolean or a string. They correspond logically to disjunctions.
Used in combination with products, they can represent arbitrary tree-like
structures, allowing to model a large class of data
(\ref{fig:union-adt-ex}).


\change{These next few labels need to be inside figures,
they are not working}
\label{fig:union-adt-ex}
\begin{lstlisting}[title={Tree-like data structure}]
type BinaryTree =
Integer @| (BinaryTree, BinaryTree)
\end{lstlisting}


In addition to internal program representations, unions are also useful to model
external data:
\begin{itemize}
    \item To represent nullable values (\ref{fig:union-nullable-ex}).
    \item For plain enumerations (\ref{fig:union-enum-ex}).
    \item To support different representations of the same data
        (\ref{fig:union-alt-ex}).
\end{itemize}
All of which are common in configurations.

\label{fig:union-nullable-ex}
\begin{lstlisting}[title={Nullable values}]
optionalValue : Str @| Null
\end{lstlisting}

\label{fig:union-enum-ex}
\begin{lstlisting}[title={Plain enumeration}]
protocol : `Http @| `Ftp @| `Sftp
\end{lstlisting}

\label{fig:union-alt-ex}
\begin{lstlisting}[title={Alternative representations}]
person : {name : Str, age : Int}
  @| {name : Str, dateOfBirth : Str}
\end{lstlisting}

In statically typed languages, and more specifically in functional programming
languages, sums (also called tagged unions, or discriminated unions) are usually
preferred, as constructors for algebraic datatypes. [references]. Sums are unions' cousin where the alternatives are
syntactically separated by an associated discriminating label. Well-known
programming languages with first-class tagged unions include Haskell, OCaml,
Rust, Scala, PureScript, Elm, Swift and many more.

On the other hand, in dynamically typed languages, it is customary to directly
store different kinds of data in one variable without further ceremony. The
runtime system needs to attach type tags to values anyway, which can usually be
observed using functions like JavaScript's \verb+typeof+. Using such bare
unions\resolved{If you can observe with typeof, then it's pretty much a tagged
union, though the tag is implicit} has already been an idiom in dynamically
typed language for a long time. Being able to type and handle these unions is an
important aspect of the migration to a gradual type system. Indeed, a lot of
\resolved{This is the first time discussing gradual type systems, maybe it should
be introduced earlier, in particular how they relate to contracts
(I think is mentioned on the appendix)}
gradually typed languages either existed originally as dynamically typed
language or aim at backward compatibility with a dynamically typed base
language. This is why despite the presence of a static type system, gradually
typed languages tend to favor bare unions types which is the typed counterpart
of this practice (as e.g in TypeScript \cite{TypeScriptUnions}).

In the case of Nickel, there is no pre-existing untyped language that we have to
support, so we are freer of our choice. However, Nickel is a configuration
language, whose contract and type system is intended to encode data schemas encountered in the wild. Since these schemas do use
untagged unions, there is a strong incentive to support untagged unions at the
type level, or at least, at the contract level.

\subsection*{Intersections}

Intersections are less prevalent. An intersection is a value that belongs to
two types at the same time. A simple example is a number literal \nickel{1}
which could be accepted as both an \nickel{Int} and a \nickel{Float} without
having to perform conversions (Figure~\ref{fig:intersection-subytping-ex}). In
this example, the intersection \nickel{Int @& Float} can be used as a subtype of
both \nickel{Int} and \nickel{Float}.

\label{fig:intersection-subytping-ex}
\begin{lstlisting}[title={Value subtyping}]
1 : Int @& Float
\end{lstlisting}

Intersections of higher-order types corresponding to overloading
(Figure~\ref{fig:intersection-overloading-ex}).

\label{fig:intersection-overloading-ex}
\begin{lstlisting}[title={Overloading}]
incr: (Int -> Int) @& (Float -> Float) =
  fun x => x + 1
\end{lstlisting}

They can also be used to combine constraints (such as traits or interfaces), as
done in Scala 3 (Figure~\ref{fig:intersection-mixins-ex}).

\label{fig:intersection-mixins-ex}
\begin{lstlisting}[language=Scala,title={Structural mixins}]
Comparator: {cmp: T -> T -> Bool}
Shower: {show: T -> String}

showSmaller : (dict: Comparator & Shower) -> T -> T -> String
\end{lstlisting}

Finally, intersection naturally show up as the dual of unions. Thus, in a system
featuring unions, a union in a negative positions is a form of intersection
(Figure~\ref{fig:intersection-dual}).

\label{fig:intersection-dual}
\begin{lstlisting}[title={Intersection as the dual of unions}]
f : (Num @| Str) -> Bool
(*@ $\simeq$ @*) f : (Num -> Bool) @& (Str -> Bool)
\end{lstlisting}

\todo{Either here or the next section, show examples of unintuitive behaviour
of U and I. For example, I is not jos composition of contracts.
And union has to be treated as any one of the options}
% Things to settle: how to motivate them, how to compare them to ADTs. Purely
% dynamic approach, or typed approach too?

\newpage

\section{Issues coming from the semantics}
\label{sec:issues-sem}
\info{What goes wrong or difficult when trying to implement union and
  intersection literally}

Static typing is about enforcing that some property always holds for a
potentially unknown value, no matter the execution part. A dynamic check, on the
other hand, just need to verify a property for a specific and known value, which
is usually much easier. For example, dependent function types are complex and
mostly implemented in proof assistants (although they are slowly making their
way in some mainstream languages), whereas the corresponding dependent function
contracts can be implemented in a few line of code (as is done in
Racket~\cite{}).

The gist of the present paper is to bring evidence that in the case of union and
intersection, the dynamic checking part is complex as well: \emph{unions and
intersections are fundamentally hard}.

% Teo's version
% Implementing a static type system is not an easy task.
% Type systems featuring intersection types are hard in a fundamental way,
% from their discovery, they've been studied as a form to characterize
% lambda-calculus terms normalizability; which means that typechecking a
% term on a system with intersection types is undecidable,
% similar to how the halting problem is undecidable\todo{reference}.
%
% Usually, when thinking about programming languages, there's an intuition
% that static checks (like typechecking) are more difficult and less powerful
% than dynamic checks (like testing).
% For instance, it is very easy to check if,
% in a given execution of a program, a variable holds an integer value; while it
% may become more challenging to check if a variable will always hold an integer value,
% no matter the particular execution.
%
% As we intend to show on this paper, unions and intersections are not only
% statically hard to check, but they are also dynamically hard:
% \emph{they are fundamentally hard}.
% In this section, we present intuitively the main challenges that arise
% when attempting to develop a runtime check system for unions and intersections.

\subsection*{Union contracts as an effect}

In a pure language with standard contracts, the failure of a function contract
can always be blamed on a single call. Figure~\ref{fig:pos-to-pos} shows a
function with a simple contract attached that ensures that both the argument and
the result of \nickel{f} are positive numbers. \nickel{f} is called twice, and
the second call violates the requirement on the codomain, leading to blame
\nickel{f}. The first call to \nickel{f} does not matter, and \nickel{5} is a
single and independent witness of the violation of the contract. The user can be
pointed to one location in practice.

There is an intuitive justification for this fact. Apart from the error
reporting part (but this is the crucial in practice!), the current contract
system of Nickel can be implemented purely as a library, just given a
\nickel{fail} primitive to abort the execution. In particular, applying a
function contract to \nickel{f} replaces it with a guarding function
\nickel{fWrapped} that performs the required checks. Thus, in a pure setting,
the failure of \nickel{fWrapped 5} must be independant of its environment, and
in particular of the call \nickel{fWrapped 10}.

% When programming with dynamic checks it is assumed that lack of
% failure does not mean that the program works perfectly.
%
% For instance, imagine having a function wrapped in a contract
% that checks that it maps positive numbers to positive numbers,
% and using it in different ways,
% like the program on Figure \ref{fig:pos-to-pos}.
% Clearly, there is an error on this program, but if the first call
% to \nickel{f} that gets executed is \nickel{f 10}, the error will not
% be found at that point, and the first operand of the addition would be
% evaluated to \nickel{3}.
% If, later on, \nickel{f 5} gets executed, the contract would get violated,
% since \nickel{f} gets called with a positive value, but returns a negative
% one (\nickel{-2}).

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f | Positive -> Positive
      = fun x => x - 7 in
(f 10) + (f 5)
\end{lstlisting}
\caption{Simple contract violation}
\label{fig:pos-to-pos}
\end{figure}

% Even if the program performed two different applications of \nickel{f}
% before finding the contract violation, the first one is not actually
% needed, and executing only \nickel{f 5} is enough to find the problem.
%
% Having a witness of size 1 for every contract failure is a really nice to have property
% since it means, for example, that every time that a contract is violated,
% the stack trace is enough to understand how it was violated, and to potentially
% come up with a minimal example that breaks the contract.
% However, when unions get introduced, this property is lost.

Union contracts are a different matter. Consider the program presented in
Figure \ref{fig:wrong-union-function}. \nickel{f} is again violating the
contract, as it neither maps positive numbers to positive numbers nor positive
numbers to negative numbers.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f | (Positive -> Positive)
        @| (Positive -> NonPositive)
      = fun x => x - 7 in
(f 10) + (f 5)
\end{lstlisting}
\caption{Union contract violation}
\label{fig:wrong-union-function}
\end{figure}

In a system with unions, this contract would fail, because \nickel{f 10}
(returns \nickel{3}) is a witness of \nickel{f} failing the contract
\nickel{Positive -> NonPositive}, and \nickel{f 5} (returns \nickel{-2}) is a
witness of \nickel{f} failing \nickel{Positive -> Positive}.  But, as opposed to
the previous example, removing one call or the other will make the program pass!
Indeed, the first call only fails the \nickel{Positive -> NonPositive} part of
the union, while the second one only fails the \nickel{Positive -> NonPositive}
part. Both are needed to prove the violation of the full contract.

Even in a pure setting, unions introduce a form of effect at a distance: the
result of \nickel{f 5} is not local anymore, as it now depends on the previous
execution of other calls to \nickel{f}. Unions contracts break the
equation~\ref{eq:cbn-expansion} of Section~\ref{sec:optimizations}, and the
candidate example of Figure~\ref{fig:optimizations-let-floating-ex} cannot be
optimized in general.

Figure~\ref{fig:optimized-programs} illustrates this point further. It comprises
an original program, and one where the common subexpression \nickel{f 1} have
been eliminated. These two programs behave very differently:
\begin{itemize}
    \item The original version returns \nickel{(1, "False")} without failing.
    \item The optimized version fails with a contract violation.
\end{itemize}

since the single application of \nickel{f 1}, applied to both \nickel{true} and
\nickel{false} will be able to find the error on the union contract
\nickel{(Bool -> Num) @| (Bool -> Str)}.


\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Original]
let f | Num -> (Bool -> Num @| Bool -> Str)
      = fun x y => if y then x else "False"
in (f 1 true, f 1 false)
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Optimized]
let f | Num -> (Bool -> Num @| Bool -> Str)
      = fun x y => if y then x else "False"
let g = f 1 in
(g true, g false)
\end{lstlisting}
\caption{Equivalent programs, with inlining or CSE applied}
\label{fig:optimized-programs}
\end{figure}

\unsure{WARNING: what is below is being reworked by Yann}

To sum up, union contracts introduce a form of effect at a distance. This
impacts both the programmer and the compiler or interpreter:
\begin{itemize}
    \item As for any side-effect, this breaks local reasoning.
    \item It prevents optimizations.
\end{itemize}
\todo{WIP}

A valid argument against this point would be stating that further work should be done
on optimizers, so to not modify these tricky cases, even if this is true,
programmers also modify their code on a daily basis, and if moving from the first
code snippet at Figure \ref{fig:optimized-programs} to the second one changes
the behaviour of a program, we argue that union contracts not only go against the
implementation of languages, but also against their usability.

Summing it up, wrapping a value with a union of higher order contracts means that
that value now has a state, that may get modified silently at every use site.
Both reviewed papers suffer from this defect since it is the semantics
of unions that interact badly with code manipulation operations,
not a particular implementation.
This addition of global state complicates both the work of the language
implementor, as well as the language user, since it adds non trivial
side effects to your code.


\subsection*{User defined contracts do not intersect}
\label{sec:flat-and-inter}

Stop for a second and think how you could implement an intersection
contract. The first thought you may have is "just apply
both contracts", as shown on the Implementation snippet
from Figure \ref{fig:inter-contracts}.
Of course, if it were that simple we wouldn't be writing this paper.
This idea starts to show problems when you first combine it with
higher order contracts, since it would mean not complying with
at least one of these contracts negatively would entail breaking the
whole thing, as shown on the second example on the same Figure,
that would fail.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Implementation]
x | A @& B (*@ $\simeq$ @*) (x | A) | B
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Problem]
let g | Num -> Num @& Str -> Str
      = fun x => x in
g 1
\end{lstlisting}
\caption{Implementations of intersection contracts: first iteration}
\label{fig:inter-contracts}
\end{figure}

Not all hope is lost, we could pass some extra shared state
to each one of the sub contracts and let them only fail if the other
side of the contract has failed as well, as shown in Figure
\ref{fig:inter-contracts-2}, where the shared state is
represented by a label \nickel{l}.
This idea is still quite reasonable, for instance, when executing
\nickel{g 1}, from Figure \ref{fig:inter-contracts}, the first contract
that gets checked is the argument of \nickel{Str -> Str} over the function parameter, so
something like \nickel{1 | Str}.
Of course, this fails, but before raising a violation, this contract could
check if the other side of the intersection (\nickel{Num -> Num}) has
also tried to raise negative blame on the same parameter ()\nickel{1}), since
it hasn't, the contract would return normally, and would mark itself as failed.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Implementation]
x | A @& B (*@ $\simeq$ @*) (x | A[l]) | B[l]
\end{lstlisting}
\caption{Implementations of intersection contracts: second iteration}
\label{fig:inter-contracts-2}
\end{figure}

On the other hand, if you were to do something like
\nickel{g true}, that would fail also negatively the contract
\nickel{Str -> Str} and, when checking if \nickel{true}
is a correct parameter for \nickel{Num -> Num} it would check
if the other side of the intersection has failed, and since it
has, a violation would be raised and the whole program would
correctly fail.

This idea, which is an oversimplification of the ideas
presented by Williams, Morris, and Wadler, seems to be spot on.
However, it presents a major problem, it's not compatible with user defined contracts,
as presented in Section \ref{sec:flat-contracts}.
Consider the example presented on Figure \ref{fig:inter-flat-contracts}, if the
implementation discussed previously were to be used, we may end up with
something like this \nickel{((fun x => x) | (Str -> Str)[l]) | C[l]}, where
\nickel{l} represents the shared state.
At this point, the intuitive thing to do is to check the contract \nickel{C}, by
checking if \nickel{((fun x => x) | (Str -> Str)[l]) 0 == 0}.  This will fail,
since applying a function wrapped in \nickel{Str -> Str} contract to \nickel{0}
fails negatively.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let C = fun f => (f 0) == 0 in
let g | (String -> String) @& C
      = (fun x => x) 
\end{lstlisting}
\caption{Intersection and user defined contracts}
\label{fig:inter-flat-contracts}
\end{figure}

But this should not have happened, since in the program of Figure \ref{fig:inter-flat-contracts}
\nickel{g} is never applied to \nickel{0}, in fact, it is never applied
to anything.
Checking if \nickel{C} has already failed, and marking \nickel{String -> String} as
failed negatively on \nickel{l} is not enough, the contract \nickel{String -> String}
should not have been used inside the evaluation of \nickel{C}, which
adds an extra layer of complexity: contracts should be guarded, and execution
depends on the shape of the surrounding evaluation context.

\subsection*{Union and intersection are not a silver bullet}

Before wrapping up this section, we would like to show that maybe, union and intersection
contracts are not exactly what we would want them to be.
As stated throughout this work, programmers coming from dynamic languages
are accustomed to perform safety checks (data validation) with
great amounts of flexibility and the whole power of their
language of choice at their disposal.

For instance, a Python programmer may have no problem in checking
at runtime, that a given variable is an integer if a given flag is
not set, as shown in Figure \ref{fig:python-assertion};
while a Haskell programmer might close her eyes and leave the room
instantly.

\begin{figure}[h]
\begin{lstlisting}[language=python]
result = 42 if flag else "Disabled"
...
assert (
  (not flag) 
  or isinstance(result, int)
)
\end{lstlisting}
\caption{Asserting at runtime the type of a variable}
\label{fig:python-assertion}
\end{figure}

These expectations are not really met by how unions and intersections
contracts are supposed to work.
For example, consider the Nickel code shown on Figure
\ref{fig:intersection-distrbution}, at first sight, this code should
complete execution successfully, returning \nickel{(1, 1)},
however, under both the Keil and Thiemann, as well as the
Williams, Morris, and Wadler works, this program will fail, with a violation
of the contract imposed to \nickel{g}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f = fun x y => x in
let g = f | (Num -> Num -> Num)
            @& (Num -> Bool -> Num) in
let h = g 1 in
(h 1, h true)
\end{lstlisting}
\caption{Intersection contracts don't distribute}
\label{fig:intersection-distrbution}
\end{figure}

The reason this happens is that there is a fundamental property of how
intersection contracts behave: the choice of which branch to choose is made
exactly when the intersection is opened up, and not delayed as much as possible,
as one would like.  This means, that the contract presented on Figure
\ref{fig:intersection-distrbution}, \nickel{Num -> Num -> Num @& Num
-> Bool -> Num}, will not behave the same way that \nickel{Num ->
(Num -> Num @& Bool -> Num)}, when, with an intuitive view of how
intersections should behave, these two expressions should be logically
equivalent.

It is worth noting, that intersection types do have this property,
since subtyping would allow to correctly type check a term like
\nickel{g 1} as both \nickel{Num -> Num} as well as
\nickel{Bool -> Num}, and then deducing that \nickel{g 1}
can be given the type \nickel{Num -> Num @& Bool -> Num}.

\newpage

\section{Issues in concrete restrictions from the literature}
\label{sec:issues-literature}
\info{The various papers and the tradeoffs they make}

The existing work that previously researched and implemented
union and intersection
as dynamic checks have, in our eyes, different shortcomings
that makes them suboptimal solutions.
In this section, we informally present those issues,
starting with the foundational paper by Keil and Thiemann
\cite{KeilThiemannUnionIntersection}, then following to a recent
work by Williams, Morris, and Wadler \cite{RootCauseOfBlame}, and
finally going over some similar contracts available in the Racket
programming language.

\subsection*{Keil and Thiemann}
\label{sec:keil-thiemann}
\unsure{Subsection title?}
Keil and Thiemann noticed that, since union contracts should share information between
different application contexts, while intersection contracts should behave
independently between each application context, the system becomes much
simpler if every contract gets transformed into a union of intersections
of other contracts, by using the common De Morgan laws,
and then eagerly opening up unions, but postponing intersection
contracts as much as possible.
\todo{This assumes the difficulty has been previously explained}

For instance, if someone were to wrap a value \nickel{x}
in a contract as shown on the Original code snippet on Figure
\ref{fig:kt-contract-transf}, then, before actually executing that
contract, it would get transformed, and intersections would
be pushed inside the unions, as can be seen on the Transformed
code snippet on the same figure.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Original]
x | A @& (B @| C)
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Transformed]
x | (A @& B) | (A @& C)
\end{lstlisting}
\caption{Contract transformation performed by the Keil and
Thiemann work}
\label{fig:kt-contract-transf}
\end{figure}

This straightforward idea makes composing the Keil and Thiemann
solution with other existing systems more difficult; in the words
of Williams, Morris, and Wadler (see Section~\ref{sec:will-morr-wadl}):
``(\ldots) the monitoring semantics for contracts of intersection and union types given by Keil
and Thiemann are not uniform. (\ldots) If uniformity helps composition, then
special cases can hinder composition.''\cite{RootCauseOfBlame}.
\info{(Yann) Does
it also make it less efficient? If $(A \cap B)$ fails because of $B$, their
development causes to recheck the contract $A$ that has been duplicated?}
And it also could harm performance, or at least complicate an implementation,
since some sharing mechanism should be used to avoid checking the same contract,
over the same value, multiple times, exemplified by contract \nickel{A} on
Figure \ref{fig:kt-contract-transf}, that gets duplicated.
\unsure{Arnaud says: this whole
section is too abstract give concrete code and explain what goes
wrong. It's fine to give code in Nickel syntax}

Another difficult issue Keil and Thiemann were able to solve, is the
fact that user defined contracts and intersection do not usually play nice
together, as shown on Section \ref{sec:flat-and-inter}.
They provide two different sets of rules for their calculus,
the first one is non deterministic, and its purpose is to provide
semantics that are simple to understand.
With these rules, the interaction between user defined contracts and
intersections becomes much simpler, since they are able to check
both sides of an intersection on separate threads.
This allows them to be sure that contracts from one branch of the intersection
won't get blamed while executing the other branch, and vice versa.

As an example, consider the programs shown on Figure
\ref{fig:kt-non-deterministic}, if the Original program
gets executed, it will spawn two instances of said program,
one with the first branch of the intersection (\nickel{3 | Num}),
and the other one with the second branch (\nickel{3 | Positive}),
and these will get joined once they reach an equal point, in this case
it will be \nickel{3}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Original]
3 | Num @& Positive
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=First Program]
3 | Num
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Second Program]
3 | Positive
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Joined Program]
3
\end{lstlisting}
\caption{Non deterministic intersection contract opening}
\label{fig:kt-non-deterministic}
\end{figure}

The second set of rules is deterministic, and it is intended
to be simpler to implement.
However, this second set needs to perform operations
on the evaluation context, to decide whether or not to evaluate
a given contract.
\footnote{You can check more on this topic on Section 5.1 of
\cite{KeilThiemannUnionIntersection}}
For instance, in the program presented on Figure \ref{fig:inter-flat-contracts},
when using the value \nickel{(fun x => x) | Str -> Str)}
inside the execution of contract \nickel{C}, and applying it to \nickel{0},
the contract runtime would check the context of execution and it would
deduce that contract \nickel{Str -> Str} does not apply in this case,
skipping it.

We see two problems here, a minor one is the fact that the two
different semantics defined for the calculus are really far apart
one from the other, both on the strategies used for contract resolution,
as well as on the complexity levels.
\resolved{(Yann) Is it really a
    problem per se? It is common thing to do (a nice declarative system
    for proofs and an algorithmic one for implementation, proved equivalent).
    Maybe the point is that the algorithmic system is way more complex than the
declarative one
(Teo) reworded}.
A second, major one,
is the dependency added over the evaluation context, since, again,
it makes composing this, with other features desired on programming languages,
difficult, or even impossible.
\resolved{(Yann) I think we need to substantiate this claim. If this
context dependency explains why CSE is invalid, maybe have a little example?
(Teo) I removed it, I don't think there's an example, mainly since
this context dependency is not part of the language. I do think it complicates
implementation of said feature}
\todo{(Yann) TODO: see if there's a low hanging complexity
    argument we can make (like it's quadratic in the number of open contracts or
whatever)}

\subsection*{Williams, Morris, and Wadler}
\label{sec:will-morr-wadl}
\unsure{Subsection title?}

Williams, Morris, and Wadler, take a different approach on user defined contracts,
they are completely forbidden in their system, explicitly to not encounter
the previously mentioned issue.
This restriction goes against what is usually expected from dynamic checks:
validation of data, and not just inclusion on types.

On top of that, a fundamental problem arises on said paper,
symptom of the difficulty of establishing good enough, and yet
simple semantics for union and intersection dynamic checks.
One of their main results, is the fact that their calculus obeys
all of their expected monitoring properties for higher ordered, union
and intersection contracts.
However, one of these properties states the following:

\begin{figure}[h]
$$ K \in \llbracket A \cap B \rrbracket^-~if~K \in \llbracket A \rrbracket^- \lor K \in \llbracket B \rrbracket^- $$
\caption{Sound monitoring property for intersection from Williams, Morris, and Wadler.}
\label{fig:wmw-semantics}
\end{figure}

Which means that a continuation $K$ complies negatively with an
intersection of $A$ and $B$ if it complies negatively with at least one of these.
Or, less formally, that if you have a program that is missing a value at a given point,
you can put a value wrapped with a contract stating $A \cap B$,
and expect not to get a negative violation of that contract,
if you can either put a value
wrapped with $A$, or a value wrapped with $B$.

Altough this is true, it's a weaker statement of what we'd like to have,
consider the two contexts presented on Figure \ref{fig:valid-contexts},
the first one is a valid context for a \nickel{Num -> Num} function,
that is, you could replace the $\square$ by some function wrapped in a
\nickel{Num -> Num} contract, and the context will not violate it.
Similarly, the second context from the same figure is a valid
\nickel{Bool -> Bool} context.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=\nickel{Num -> Num} context]
(*@$\square$@*) 3
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=\nickel{Bool -> Bool} context]
(*@$\square$@*) true
\end{lstlisting}
\caption{Two different contexts in Nickel}
\label{fig:valid-contexts}
\end{figure}

Next, we can combine these two contexts into one, that essentially
has one single missing value, that will be used independently in both contexts
from Figure \ref{fig:valid-contexts}, as shown on Figure \ref{fig:invalid-context}.
This context is not a valid \nickel{Num -> Num} context, since it will apply
the value put on $\square$ (through \nickel{f}) to a non \nickel{Num} (\nickel{true}).
In a similar way, it is not a valid \nickel{Bool -> Bool} context either.
Therefore, according to the semantics from the Williams, Morris, and Wadler paper, as
shown on Figure \ref{fig:wmw-semantics}, it is not a valid
\nickel{Num -> Num @& Bool -> Bool} context.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f = (*@$\square$@*) in
(f 3, f true) 
\end{lstlisting}
\caption{Invalid \nickel{Num -> Num @& Bool -> Bool} context,
combining contexts from Figure \ref{fig:valid-contexts}}
\label{fig:invalid-context}
\end{figure}

However, both our intuition, as the most common use case of intersections
(that is, overloading), tells us that this should work.
While this problem does not invalidate their work (in fact, the system they present
handles these cases correctly), it shows that existing research is still not on
good shape to handle the growing usecases being developed for
unions and intersections around dynamic languages.

% $$ K ::= Id | K \bullet \square N | K \bullet V \square | K \bullet \square @^pA  $$

% Keil and Thiemann did noticed this problem, and their contract satisfaction
% rules only apply to elimination context, a particular kind of context
% where the hole is either being applied to an argument
% ($\square N$) or is used as an argument for a primitive
% operation ($O(\overrightarrow{\text{V}}, \square, \overrightarrow{\text{N}})$).



% K ::= Id | K ◦ □ N | K ◦ V □ | K ◦ □ @pA
\resolved{(Yann) Maybe adding a concrete example of this (it can be the same term but with
    concrete types like Number and String and simple contexts like application
    to a dumb argument) is sufficient to make the point}

\subsection*{Racket}
\label{sec:racket}


Racket is a language based on Scheme, mainly thought as a language to experiment
with different language desings and ideas. It provides a very complete contract
system\cite{RacketContracts}.

Among those contracts, they provide \racket{and/c} and \racket{or/c} contracts.
These contracts are lightweight versions of intersections and unions, they simply
check that every contract is valid, in the case of \racket{and/c},
and that at least one contract
is valid, in the case of \racket{or/c}.

So, for instance, the usual usecase of intersection to encode bounded overloading
does not work on Racket. Take a look at the next example, the function
\racket{overload} should accept a call like \racket{(overload 3)}, but it fails
since 3 is not a valid \racket{string?}.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract overload
(and/c (-> number? number?)
       (-> string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{Non working function overloading on Racket.}

\end{figure}

Even worst, the \racket{or/c} contract doesn't allow to have multiple higher order
contracts that could (potentially) apply to a function, these have to be
differentiated by first order markers.
For instance, the code on Figure~\ref{code:racket:or/c:working}
would correctly allow only to call
\racket{united} with a \racket{number?},
and it can make this distinction since it knows that
\racket{(lambda (x) x)} can not be a function that takes 2 parameters.
However, the code on Figure~\ref{code:racket:or/c:non-working} would fail
before running, since the \racket{or/c} contract is unable to know
which of the two function contracts to use.
Ideally, this last example should just behave as wrapping
the function with the \racket{(-> even? even?)} contract.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract united
(or/c (-> number? number?)
      (-> string? string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{Working \racket{or/c} example on Racket.}
\label{code:racket:or/c:working}

\end{figure}

\begin{figure}[h]

\begin{lstlisting}[language=lisp]
(define/contract united
(or/c (-> number? number?)
      (-> even? even?))
(lambda (x) x))
\end{lstlisting}
\caption{Non working \racket{or/c} example on Racket.}
\label{code:racket:or/c:non-working}

\end{figure}


\unsure{This section is overall a bit hard to follow. I
  think I've figured out what it means, but it needs more love. Also
  give an example which doesn't work and one that does for or/c.}

\subsubsection*{case->}

Racket does provide an alternative for overloading methods, called the
\racket{case->} contract, however, this overloading of methods only
works over contracts of functions with different amount of parameters.
It's a good alternative to allow limited overloading of functions.
As an example, consider the following non failing piece of code, and
try to understand how Racket can decide, at each application,
which function contract to use.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract overcase
  (case-> (-> string? string?)
          (-> number? number? number?)
          )
  (lambda (x [y 0]) (if (number? x)
                   (+ x y)
                   x)))

(overcase 1 2)

(overcase "hello")
\end{lstlisting}
\end{figure}

Even if Racket's intent is not to implement union and intersection
dynamic checks, they do provide contracts that are, in some sense,
simplified versions of those.
In our eyes, Racket has accepted the difficulty of correctly and practically
combine union, intersection, and higher order contracts, and has choose
to prioritise the highe order ones.

\newpage

\section{Related work}
\label{sec:related-work}
\info{Including a mention of statically typed systems with union}

\newpage

\section{Conclusion}
\label{sec:conclusion}

The design and implementation of programming languages is a challenging task. It
is a delicate exercise to balance complexity, expressiveness, efficiency and
user experience all together. Unfortunately for designers, a language cannot
usually be reduced to a simple sum of small independent features. They are
rather composed of a lot of moving parts that interact in unexpected ways. The
more a language grows, the more any new addition has to be weighted carefully,
as it has the potential to interact with any of the existing features.

Part of recent developments revolve around mixing static typing and dynamic
typing via gradual typing, in order to get the best of both worlds. Contracts
(or casts in the gradual typing terminology) are crucial to this endeavour by
allowing for a safe interaction between typed and untyped code. But we also made
a case that contracts are interesting in themselves in a fully dynamically typed
language (and even in a fully statically typed language).  Contracts are a
precious idiom for data validation or to check pre- and post-condition that
would be hard to ensure statically. In spirit, contracts are similar to
assertions, but they are part of a principled framework, they are composable,
they have good error reporting and they are integrated as a language feature. In
particular, contracts natively handles higher-order functions and built-in data
structures. This makes them an great candidate for integration in the Nickel
configuration language.

This is only the beginning of the story. A language designer then has to choose
what contract combinators to provide among a number of possibilities: there is
the standard package including higher-order function contracts, record contracts
and list contracts.  Then, one could add polymorphic
contacts~\cite{BlameForAll}, dependent function
contracts~\ref{DependentContracts}, and so on. For validation purpose, union and
intersection contracts are really appealing. Unions have a intuitive
interpretation as modeling alternatives and thus appear implicitly or explicitly
in a lot of data structures.

Alas, the implementation of union and intersection contracts is not as simple as
it first appears. In conjunction with higher-order contracts, or even just basic
contracts in a lazy language, they behave in a way that is reminiscent of
side-effects. These behaviors were, for most of them, already known: we do not
claim their discovery. However, as language implementers, we have made an actual
attempt at including them in a concrete language. We exposed what, in our
opinion, are the most important barriers and their impact on the rest of the
language. Even in a pure setting, union and intersection contracts break the
equivalence between call-by-name and call-by-value, and can consequently prevent
optimizations. There are discrepancies between the expected and actual semantics
that make some behaviors unintuitive. Their implementation is a non-trivial
change that contaminates the evaluation of all other contracts, and the
performance penalty is not obvious to assess.

To conclude, let us make clear that we do not think union and intersection
contracts are fundamentally broken, that they can not be implemented correctly,
or that they do not bear any value (quite the contrary). They may still make
sense to have in a language, and some apparent difficulties in the
implementation could be lifted some day. But as often, there are gaps between
the theoretical foundation, a proof-of-concept, a prototype, and the integration
in an actual language. We hope that our attempt may serve as a cautionary tale:
for union and intersection contracts, these gaps might be quite large in places.

\bibliography{nickel}
\end{document}

% LocalWords:  Felleisen JSON TOML YAML templating Jsonnet Dhall MyPy
% LocalWords:  Kubernetes DevOps natively nixpkgs disjunctions
% LocalWords:  TypeScript
