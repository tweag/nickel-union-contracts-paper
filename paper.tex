\documentclass[sigplan,10pt]{acmart}
%\usepackage{amssymb}
\usepackage{mathtools,amsmath,amsfonts,amsxtra,amsthm,mathrsfs,mathpartir}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\usepackage{varioref}
\usepackage{verbatim,comment}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{url}
\usepackage{hyperref}

%%%%%%%%%%%%%%%%% Editing marks %%%%%%%%%%%%%%%%%

  % TOGGLE ME to turn off all the commentary:
  \InputIfFileExists{no-editing-marks}{
    \def\noeditingmarks{}
  }

  \usepackage{xargs}
  \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
  % ^^ Need for pgfsyspdfmark apparently?
  \ifx\noeditingmarks\undefined
      \setlength{\marginparwidth}{1.2cm} % A size that matches the new PACMPL format
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
      \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
      \newenvironment{alt}{\color{red}}{}

      \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
      \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
      \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
      \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
      \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
  \else
  %    \newcommand{\Red}[1]{#1}
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{#1}
      \newcommand{\note}[1]{}
      \newenvironment{alt}{}{}
  %    \renewcommand\todo[2]{}
      \newcommand{\unsure}[2][1=]{}
      \newcommand{\info}[2][1=]{}
      \newcommand{\change}[2]{}
      \newcommand{\inconsistent}[2]{}
      \newcommand{\critical}[2]{}
      \newcommand{\improvement}[1]{}
      \newcommand{\resolved}[2]{}
  \fi

%%%%%%%%%%%%%%%%% /Editing marks %%%%%%%%%%%%%%%%%

\bibliographystyle{ACM-Reference-Format}

\begin{abstract}
This paper reports an attempt to incorporate union and intersection types in
Nickel, a configuration programming language with a gradual type system and
first-class contracts. While the end result looks appealing, it turns out the
concrete impact on both the design and the implementation of the language is
unexpectedly high. We review the issues raised in particular by the
implementation of contracts for unions and intersections, and why we think the
cost ends up too high for the benefit. We conclude by suggesting different leads
to represent and type unions.
\end{abstract}


\title{Contracts for unions and intersections are hard for Nickel}
\author{Teodoro Freund, Yann Hamdaoui, Arnaud Spiwack}

\begin{document}

\maketitle

\section{Introduction}
Intro\unsure{todo}
\info{Goals of the paper: position paper: unions/intersections nice in
theory problematic in practice. In particular non-orthogonal with the
rest of the features of your language.}

\newpage

\section{Features of languages}
\info{Zoology of various features that we will eventually show
  conflict with this or that property or implementation of union and
  intersection. Including user-define contracts.}

Programming language research no longer lives on the abstract world
of ideal surfaces.
Every addition needs to be compatible with years of research
and development, and this is hard.
Success was unavoidable.

In this section we briefly introduce some aspects of real world
programming languages that will cause trouble while interacting
with union and intersection dynamic checks.

\subsection*{User defined (flat) contracts}

User defined contracts, also called flat contracts, are a particular
kind of contract that behaves similar to an assertion, and whose
main point is to apply some arbitrary predicate (as arbitrary as the
host language allows it) to a value; if the predicate returns true,
the contract passes, otherwise it fails.

For instance, we could define a flat contract $even?$ as 
$\lambda x. ~ x ~ \% ~ 2 ~ == ~ 0$, that checks
whether a number is even.
And then use it to check that a function always returns an
even number, for example:

$$let~f~=~(\lambda n. ~ n * 2)@Number ~ \rightarrow ~ even?$$

\unsure{Do we need deeper examples?}

This kind of contracts are present on many different languages,
for instance, the Eiffel programming language, the precursor
on the Design by Contract ideals, allows to assert
exactly these kinds of expression as pre- and post-conditions on
functions.

The Racket programming language also has a system to work with
contracts\footnote{And a gradual typing system
built on top of that, but that goes beyond the scope of this
work.} that provides a mechanism for defining them; and
composing these with other kinds of constructs.

Even if flat contracts may seem like too much, these are expected
by programmers on dynamic languages, where testing and runtime
assertions are a common pattern for safe programming, and 
programmers are used to express complex predicates
over values.


\subsection*{Code manipulation (optimizations)}
\info{Present inlining and CSE as two major code
optimizations.
Purity and immutability as two important factors.}


\newpage

\section{Union \& intersection}
\info{What are they, what are they used for.}

\newpage

\section{Issues coming from the semantics}
\info{What goes wrong or difficult when trying to implement union and
  intersection literally}

\newpage

\section{Issues in concrete restrictions from the literature}
\info{The various papers and the tradeoffs they make}

The papers that previously researched union and intersection
as dynamic checks have, in our eyes, different shortcomings
that makes them suboptimal solutions.

Starting with the Keil and Thiemann work \cite{KeilThiemannUnionIntersection},
they noticed that, since union contracts should share information between
different application contexts, while intersection contracts should behave
independently between each application context, the system becomes much
simpler if every contract gets transformed into a union of intersections
of other contracts, by using the usual De Morgan laws,
and then eagerly opening up unions, but postponing intersection
contracts as much as possible.
\todo{This assumes the difficulty has been previously explained}

This straightforward solutions makes composing the Keil and Thiemann
system with other existing systems more difficult; in the words
of Williams, Morris, and Wadler:
"(...) the monitoring semantics for contracts of intersection and union types given by Keil
and Thiemann are not uniform. (...) If uniformity helps composition, then
special cases can hinder composition."\cite{RootCauseOfBlame}

Another difficult issue Keil and Thiemann were able to solve, is the
fact that flat contracts and intersection do not usually play nice
together.
They provide two different set of rules for their calculus,
the first one is non deterministic, which purpose is to provide
semantics that are simple to understand.
The second one is a deterministic set of rules, that are intended
to be simply to implement. These semantics need to perform operations
on the evaluation context, to decide whether or not to evaluate
a given contract.

We see two problems here, a minor one is the fact that two different
semantics need to be defined, which translates either to a difficult
to implement or a difficult to understand system. A second, major one,
is the dependency added over the evaluation context, since, again,
it makes composing this, with other features desired on programming languages,
difficult, or even impossible (as the case with common subexpression elimination).

Williams, Morris, and Wadler, take a different approach on flat contracts,
they are completely forbidden in their system, explicitly to not encounter
the previously mentioned issue.
This restriction goes against what is usually expected from dynamic checks:
validation of data, and not just inclusion on types, is an expected
feature of contracts. 

On top of that, a fundamental problem arises on said paper,
symptom of the difficulty of establishing good enough, and yet
simple semantics for union and intersection dynamic checks.
One of their main results, is the fact that their calculus, obeys
all of their expected monitoring properties for higher ordered, union
and, intersection contracts.
However, one of these properties states the following:

$$ K \in \llbracket A \cap B \rrbracket ~ if ~ K \in \llbracket A \rrbracket \lor K \in \llbracket B \rrbracket $$ 

Which means that a continuation ($K$) complies negatively with an
intersection of $A$ and $B$ if it complies with at least one of these.
Altough this is true, it's a weaker statement of what we'd like to have,
since it rules out continuations like $(\lambda f.~(K_1[f],~K_2[f])) \square$, 
where $K_1 \in \llbracket A \rrbracket$ but $K_1 \not \in \llbracket B \rrbracket$,
and dually for $K_2$, which would mean the continuation presented above would not
be in $\llbracket A \cap B \rrbracket$, even though our intuition (and the
introduction to the paper) indicates that it should.

While this mistake does not invalidate their work (the system they present
handles these correctly), it shows that existing research is still not on
good shape to handle the growing usecases being developed for
union and intersection around dynamic languages.

% $$ K ::= Id | K \bullet \square N | K \bullet V \square | K \bullet \square @^pA  $$

% Keil and Thiemann did noticed this problem, and their contract satisfaction
% rules only apply to elimination context, a particular kind of context
% where the hole is either being applied to an argument
% ($\square N$) or is used as an argument for a primitive
% operation ($O(\overrightarrow{\text{V}}, \square, \overrightarrow{\text{N}})$).



% K ::= Id | K ◦ □ N | K ◦ V □ | K ◦ □ @pA
\unsure{Is this worth mentioning? Should we go so techincal?}

\newpage

\section{Related work}
\info{Including a mention of statically typed systems with union}

\newpage

\section{Conclusion}

\appendix

\section{Background on union types}

\subsection{Nickel design space}

{\color{red}Goals of the section

Introduce Nickel, explain the choice of gradual
typing and main design orientations, such as practice-oriented, lightweight,
etc.\vspace{0.5cm}}

Build systems, package managers, operating systems, cloud infrastructures, and
web services\unsure{Also continuous integration} are examples of modern complex software systems that require an
extensive and non-trivial configuration in order to make them adapted to each
different use-case. To manage the growing complexity that is then offloaded to
configurations, the declarative approach has become more and more popular,
illustrated for example by the infrastructure-as-code paradigm. This leads
configuration to play an important role in critical aspects of software
engineering, including security, availability, and maintainability.

However, static text-based configuration alone is falling short of expressiveness,
and is seldom sufficient. Data cannot be transformed, combined nor shared,
resulting at best in boilerplate and duplication of information, or at worst, in
data being invalid or inconsistent. Data validation is not supported either, and must be handed over to yet another tool down the configuration pipeline, if ever
done. Correctly configuring a modern system is hard and failures may have
substantial negative consequences.

This is why the authors have been developing the Nickel
language\cite{NickelRepo}. Nickel is a configuration programming language,
meaning that a Nickel program evaluates to a value that must be
straightforwardly serializable to JSON, YAML or alike. Nickel aims at being
lightweight and easy to write while still providing features for writing correct
code and generating valid data. The focus is first and foremost practical:
Nickel originated as a rethink of the language of the Nix package manager, used
to describe one of the biggest sets of software packages\cite{repology}.  Nickel
targets build systems and cloud deployment tools (Kubernetes, Terraform or
NixOps) as well. While we are keen on incorporating existing or doing new
research when it solves a well-defined problem, the general design goals are
always guided by the practical industrial use cases.

\subsection{Typing}

Our aim is that writing simple Nickel feels as easy as writing JSON or YAML.
Unlike JSON, though, Nickel anticipates large configurations by being both
programmable and typed. In the configuration setting, there is a singular
dilemma with respect to typing: since a program is run on fixed inputs and is
expected to terminate, any relevant type error will show up at evaluation.  Why
bother with the complexity of a static type system? On the other hand, more and
more software systems offload complexity to configurations, in particular with
the infrastructure as code paradigm prevailing today in cloud deployment. When
the complexity of a codebase grows, static types become attractive again.  For
reusable code — that is, library functions —, static types are specifically
adapted, and bring all the usual benefits of early error detection, code
robustness, better code structure, documentation, and so on.

This dilemma is naturally solved by gradual typing\cite{Siek06gradualtyping}
which mixes both static and dynamic typing. Unlike gradually-typed languages
like TypeScript\unsure{Todo: explain that typescript uses unions as
  static typing whereas we are speaking of dynamic contracts}, we do not seek to build a complex type system that tries hard
to accept most of the idioms naturally arising in dynamically typed code.
Rather, we choose to provide a reasonably expressive type system with good
inference properties, which makes typing functions operating on generic data easy,
but may require using untyped code for more exotic expressions.  In any case,
this is not a surrender, as Nickel provides a complementary mechanism for more
advanced data validation: contracts.

\subsection{Contracts}
{\color{red}Goals of the section

A primer on contracts, which in the end are the problematic bit when confronted
with unions.\vspace{0.5cm}}

Enforcing pre- and post-conditions at runtime is a widely established practice.
In their foundational paper\cite{FindlerFelleisenHOContracts}, Findler and
Felleisen introduce a principled approach to run-time assertion checking that
nicely supports higher-order functions and introduces the notion of blame, which
is crucial to good error reporting. It became apparent later that their
contracts are closely related to the type casts introduced by gradual typing,
modulo blame: both \cite{FindlerMultiLang} and \cite{FelleisenInterLang} see the
value of contracts as a safe interface between typed and untyped code. In
\cite{WellTypedBlamed}, the authors precisely introduce a system integrating
gradual typing with contracts \textit{à la Findler \&
  Felleisen}.\unsure{The historical bit should probably be moved to
  related works eventually} Nickel adopts
a similar type system, with both statically typed terms, dynamically typed
terms, and first-class contracts. In "first-class contracts", we include the
ability to write user-defined contracts. Because built-in types are too
simplistic for the purpose of data validation, the ability of writing a small
validation function for, say, a URL, and having it immediately available as a
contract that can be composed with other type
constructors\unsure{Needs code to illustrate.}, is in our
opinion one of the main appeal of Nickel's contracts system. In this hybrid
system, each type constructor of the static type system - arrows, records,
foralls - must have a contract counterpart that checks at run-time that a value
is indeed a member of the corresponding type. Contracts for various extensions
of the simply typed $\lambda$-calculus have been investigated \cite{BlameForAll,
    KeilThiemannUnionIntersection, RootCauseOfBlame, DependentContracts,
GradualTypingClasses}, with solutions of varying complexity.  Amongst all the
common extensions to the polymorphic lambda calculus, one of the most useful and
widespread turns out to be one of the most challenging: \emph{union types}.

\subsection{Union types}
{\color{red}Goals of the section

Introduce union in general, and most usual form in statically typed languages, tagged unions\vspace{0.5cm}}

Unions are fundamental and ubiquitous building blocks of program data. A union
only holds one value whose shape is only known to be in a fixed set of
alternatives: for eample, either a boolean or a string. Wuen used in combination
with products, they can represent arbitrary tree-like structures, allowing to
model a large class of data.

Unions are also useful for configurations:
\begin{itemize}
    \item To represent nullable values in JSON.
    \item For plain enumerations. For example, the enabled protocols of a data server
        would be either \lstinline+HTTP+, \lstinline+FTP+ or \lstinline+SFTP+.
    \item To support different representations of the same data. A file path could be
        accepted either as one string of \lstinline+"/"+-separated strings, or
        as a list of strings.
\end{itemize}

In statically typed languages, and more specifically in functional programming
languages, unions are usually implemented as algebraic data
types\unsure{This is a very misleading statement at best. Sums are
  "tagged union" sure, but that refers to an encoding a sums with
  unions, certainly not an encoding of unions with sums!} [references],
also called \emph{tagged unions}. Well-known programming languages with
first-class tagged unions include Haskell, OCaml, Rust, Scala, PureScript, Elm,
Swift and surely many more.

\subsection{Tagged versus untagged}
{\color{red}Goals of the section

Interpreted languages already need to tag their values, hence bare union are more natural.
It also corresponds better to prior usage in untyped code\vspace{0.5cm}}

In the statically typed setting, the actual representation of a tagged union is
an implementation detail: from the point of view of the programmer, a tagged
union is a first-class data type associated with constructors and destructors
with well-defined semantics. In contrast, in a gradually typed language like
Nickel, the question of the representation of tagged unions as untyped values
arises.

Unfortunately, tagged unions do not have a serializable canonical counterpart as
untyped data. One usual representation is a record with a tag and a value whose
shape depends on the tag (see Figure \ref{fig:union-encoding}).

\begin{figure}
  \begin{center}
    \begin{lstlisting}
        { tag: <Integer, String>, value: Dyn }
    \end{lstlisting}
  \end{center}
\caption{Encoding of the union type: integer or a string}
\label{fig:union-encoding}
\medskip
\small
In Nickel, \lstinline+<A, B, C>+ is the type of a C-like enumeration that can
take value \lstinline+A+, \lstinline+B+ or \lstinline+C+, while \lstinline+Dyn+
is the dynamic unitype.
\end{figure}

A better way to describe it would be as a dependent pair which first component
is a tag and second component is the data type corresponding to this tag:

\[
    \Sigma_{tag : <A, B, C>} \text{Alternative}(\text{tag})
\]

Nickel does not feature dependent types, which would open a whole new level of
complexity. Alas, choosing the non dependent representation as a default is not
fully satisfying.  First, it does not map precisely to a JSON value: in
consequence, a lot of illegal combinations are structurally valid as untyped
JSON values. But this is to be expected of any representation. More importantly,
this does not necessarily match with the configuration schemas one can find in
the wild, which favor simple, untagged union.

In dynamically typed languages, it is customary to directly store different kinds
of data in one variable without further ceremony. The runtime system needs to
attach type tags to values anyway, which can usually be observed using functions
like JavaScript's \verb+typeof+. Using so-called \emph{untagged
  unions}\unsure{If you can observe with typeof, then it's
  pretty much a tagged union, though the tag is implicit} has
already been an idiom in dynamically typed language for a long time
[ref/examples], and being able to type and handle these unions is an important
aspect of the migration to a gradual type system. Indeed, a lot of gradually
typed languages either existed originally as dynamically typed language or aim
at backward compatibility with a dynamically typed base language. This is why
they tend to favor supporting untagged union types, the typed counterpart of
this practice (as e.g in TypeScript \cite{TypeScriptUnions}).

In the case of Nickel, there is no pre-existing untyped language that we have to
support, so we are freer of our choice. However, Nickel is a configuration
language, whose contracts and types system is intended to be expressive enough
to encode data schemas encountered in the wild. Since these schemas do use
untagged unions, there is a strong incentive to support untagged unions at the
type level, or at least, at the contract level.

\subsection{Tagged as untagged}
{\color{red}Goals of the section

Untagged unions, modulo a slightly smarter typechecker, can encode usual type-safe
tagged unions. They let the user free of the representation though, and encode
more stuff, that's why they are appealing.\vspace{0.5cm}}

Untagged union, together with the other existing features of the type system,
are sufficient to implement the encoding illustrated in Figure
\ref{fig:union-encoding}. For example, let us represent an algebraic data type
(written in ML syntax) as an imaginary Nickel union type:

\begin{lstlisting}
type either = Left of int | Right of string
\end{lstlisting}

\begin{lstlisting}
{ tag : <Left>, val : Num} | { tag : <Right>, val : Str}
\end{lstlisting}

There is a twist, though. As it is, the static type system is unable to refine
the type of the value, making the following example rejected:

\begin{lstlisting}
switch x.tag {
  Left => x.val + 1,
  Right => strings.fromNum x.val
}
\end{lstlisting}

Flow typing, implemented in Racket\cite{FlowTypingRacket1, FlowTypingRacket2},
Groovy\cite{FlowTypingGroovy}, Whiley\cite{FlowTypingWhiley} or
TypeScript\cite{FlowTypingTypeScript}, is capable of refining appropriately the
type information in each branch. Thus equipped with untagged unions and a
typechecker smart enough, classic tagged unions can be simulated, but with the
additional benefit that the language is not imposing any representation.
Untagged unions empower the programmer to represent and handle a wider variety
of union idioms appearing in the wild.  Thus, adding union types to Nickel
sounds appealing.

\subsection{Union and intersections}
{\color{red}Goals of the section
Explain why having unions probably unavoidably leads one to have intersection.\vspace{0.5cm}}

While our original motivation is in supporting unions, the rest of the paper
explore complete systems featuring union and intersection types. One could
wonder if the difficulties could then be sidestepped by removing intesection out
of the equation. But

\begin{enumerate}
    \item Most of the encountered issues already appear with bare unions.
    \item Intersection being dual to unions, they are showing up in some way
        when unions are put in negative positions. For example, a contract for
        $(A \cup B) \to C$ in a system without intersections must be
        equivalent\unsure{``Must be'' is a rather strong statement, we
        will find a way to tone it down}
        to the contract $(A \to C) \cap (B \to C)$
\end{enumerate}

\unsure{Some bits missing so far: we are interested in higher-order
  contracts, Nickel is a higher-order \& pure language, contracts as
  functions. We've said that user-defined contracts are a thing, it
  probably matters so we may have to hammer it down.}

\unsure{Something that we must mention somewhere: if we want to check
  that something is a list of As lazily (to avoid making functions
  like hd be O(n), for instance), then we have a lot of the problems of
  higher-order contracts anyway.}

\subsection{Performance considerations}
\info{This a draft}
\todo{transition, location}

At first sight, performance should not be a critical issue given the use cases
of Nickel. But generating large configurations can already hit some limits in
current related languages [reference?]. A natural is parallelization:
Nickel being an almost pure functional programming language, evaluating separate
files or expressions in parallel is straightforward and effective. This
parallelization potential is thus a design requirement, and must be when the
addition of union types.

\section{Challenges}
\input{challenges}

\section{Current (Real life) implementations}

\info{The goal of this section is to outline existing languages that implement
union and intersection, in some form, and shortly compare these
with the semantics tried to obtain on research (WMW, KT)}

Unions and intersection are starting to become more and more common
on non-academic programming languages, as stated on the introduction,
unions are a natural abstraction for dynamic languages, where the type
of an expression could have many different shapes, without necessarily
having a mark to distinguish between them.
With this in mind, a valid question is how do these languages solve the
union/intersection conundrum? Or, even better, what is it that they
solve?

In the rest of this section we revisit some different approaches.

\subsection{Racket}

Racket is language based on Scheme mainly thought as a language to experiment
with different language desings and ideas. It provides a very complete contract
system.

Among those contracts, they provide \texttt{and/c} and \texttt{or/c} contracts.
These contracts are lightweight versions of unions and intersections, they simply
check that every contract holds, in the case of and/c, and that at least one contract
holds, in the case of or/c.\unsure{It doesn't really make sense for a
  contract to “hold”, in general}

So, for instance, the usual usecase of intersection to encode overloading
does not work on Racket. Take a look at the next example, the function
\texttt{overload} should accept a call like \texttt{(overload 3)}, but it fails
since it 3 is not a valid \texttt{string?}.

\texttt{(define/contract overload
(and/c (-> number? number?)
       (-> string? string?))
($\lambda$ (x) x))}

Even worst, the or/c contract doesn't allow to have multiple higher order
contracts that could (potentially) apply to a function, these have to be
differentiated by first order markers (for instance, the number of
arguments).\unsure{This section is overall a bit hard to follow. I
  think I've figured out what it means, but it needs more love. Also
  give an example which doesn't work and one that does for or/c.}

\subsubsection*{case->}

Racket does provide an alternative for overloading methods, called the
\texttt{case->} contract, however, this overloading of methods only
works over contracts of functions with different amount of parameters.

\todo{Coming back to the problems of composing U/I with other typing
features, Racket has made a clear choice and decided that higher order
is more important (a wise decision)}

\subsection{Python - MyPy}

\unsure{We ought to group all the static typing in one subsection}

\bibliography{nickel}

\end{document}

% LocalWords:  Felleisen
