\documentclass[sigplan,10pt]{acmart}
%\usepackage{amssymb}
\usepackage{mathtools,amsmath,amsfonts,amsxtra,amsthm,mathrsfs,mathpartir}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\usepackage{varioref}
\usepackage{verbatim,comment}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{url}
\usepackage{hyperref}

\definecolor{OliveGreen}{RGB}{128,128,0}
%%%%%%%%%%%%%%%%% Editing marks %%%%%%%%%%%%%%%%%

  % TOGGLE ME to turn off all the commentary:
  \InputIfFileExists{no-editing-marks}{
    \def\noeditingmarks{}
  }

  \usepackage{xargs}
  \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
  % ^^ Need for pgfsyspdfmark apparently?
  \ifx\noeditingmarks\undefined
      \setlength{\marginparwidth}{1.2cm} % A size that matches the new PACMPL format
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
      \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
      \newenvironment{alt}{\color{red}}{}

      \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
      \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
      \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
      \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
      \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
  \else
  %    \newcommand{\Red}[1]{#1}
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{#1}
      \newcommand{\note}[1]{}
      \newenvironment{alt}{}{}
  %    \renewcommand\todo[2]{}
      \newcommand{\unsure}[2][1=]{}
      \newcommand{\info}[2][1=]{}
      \newcommand{\change}[2]{}
      \newcommand{\inconsistent}[2]{}
      \newcommand{\critical}[2]{}
      \newcommand{\improvement}[1]{}
      \newcommand{\resolved}[2]{}
  \fi

%%%%%%%%%%%%%%%%% /Editing marks %%%%%%%%%%%%%%%%%

%%%%%%%%%%% LST listing confinguraiton %%%%%%%%%%%

\lstdefinelanguage{nickel}{
    keywords=[1]{
      if,
      then,
      else,
      switch,
    },
    keywords=[2]{
      let,
      rec,
      fun,
      in
    },
    keywords=[3]{
      Num,
      Bool,
      Str,
      List,
      Dyn,
      forall,
    },
    keywordsprefix=\#,
    keywords=[4]{
      true,
      false,
      null
    },
    keywords=[5]{
      doc,
      default,
    },
    sensitive=true, % keywords are case-sensitive
    morecomment=[l]{//}, % l is for line comment
    morecomment=**[is][\color{gray}]{\$}{\$},
    morestring=[b]", % defines that strings are enclosed in double quotes
    morestring=[s]{m\#"}{"\#m},
    moredelim=[is][\color{gray}]{\$}{\$},
    literate=
        *{->}{$\rightarrow$}1
        {=>}{$\Rightarrow$}1
        {>=}{$\geq$}1
        {<=}{$\leq$}1
} %

% Copied from https://hal.inria.fr/hal-01140459/file/racket.inc.tex
\lstdefinelanguage{racket} {
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    define-context, define-controller, Integer, Boolean, get, when-required, when-provided,
    maybe_publish, require, submod, or/c, ->, \#\%module-begin,
    always_publish, with-syntax, define-struct/contract, syntax-case,
    define/contract,
    let-values, let*-values,
    module, provide,
    and, or, not, delay, force,
    \#`, \#',
    \#lang, implement, begin-for-syntax, rename-out,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsoletter={',`,-,/,>,<,\#,\%},
  morecomment=[l]{;},
%  literate={lambda}{{\lambdaup}}1, % lambda -- look at https://tex.stackexchange.com/questions/119879/math-symbols-in-tt-font
  moredelim=**[is][\color{light-gray}]{<<@<<}{>>@>>},
  moredelim=**[is][\itshape\color{OliveGreen}]{<<;<<}{>>;>>},
  morecomment=[s]{\#|}{|\#},
  sensitive=true,
}

\lstset{
  language={nickel},
  basicstyle=\small\ttfamily, % Global Code Style
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=2, % number of spaces indented when discovering a tab
  columns=fixed, % make all characters equal width
  keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
  showstringspaces=false, % lets spaces in strings appear as real spaces
  breaklines=true, % wrap lines if they don't fit
  frame=trbl, % draw a frame at the top, right, left and bottom of the listing
  frameround=tttt, % make the frame round at all four corners
  framesep=4pt, % quarter circle size of the round corners
  numbers=left, % show line numbers at the left
  numberstyle=\tiny\ttfamily, % style of the line numbers
  escapeinside={(*@}{@*)} % escape sequence to insert latex
  % commentstyle=\color{dark-grey}, % style of comments
  % keywordstyle=[1]\color{blue-portage}, % style of keywords
  % keywordstyle=[2]\color{orange-vivid-tangerine}, % style of keywords
  % keywordstyle=[3]\color{blue-portage}, % style of keywords
  % keywordstyle=[4]\color{green-pea}, % style of keywords
  % keywordstyle=[5]\color{pink-froly}, % style of keywords
  % stringstyle=\color{blue-marguerite}, % style of strings
}

\newcommand{\nickel}[1]{\lstinline[language=nickel]{#1}}
\newcommand{\racket}[1]{\lstinline[language=racket]{#1}}

\bibliographystyle{ACM-Reference-Format}

\begin{abstract}
This paper reports an attempt to incorporate union and intersection types in
Nickel, a configuration programming language with a gradual type system and
first-class contracts. While the end result looks appealing, it turns out the
concrete impact on both the design and the implementation of the language is
unexpectedly high. We review the issues raised in particular by the
implementation of contracts for unions and intersections, and why we think the
cost ends up too high for the benefit. We conclude by suggesting different leads
to represent and type unions.
\end{abstract}


\title{Contracts for unions and intersections are hard for Nickel}
\author{Teodoro Freund, Yann Hamdaoui, Arnaud Spiwack}

\begin{document}

\maketitle

\section{Introduction}
Intro\unsure{todo}
\info{Goals of the paper: position paper: unions/intersections nice in
theory problematic in practice. In particular non-orthogonal with the
rest of the features of your language.}

\newpage

\section{Features of languages}
\info{Zoology of various features that we will eventually show
  conflict with this or that property or implementation of union and
  intersection. Including user-define contracts.}

Programming language research no longer lives on the abstract world
of ideal surfaces.
Every addition needs to be compatible with years of research
and development, and this is hard.
Success was unavoidable.

In this section we briefly introduce some aspects of real world
programming languages that will cause trouble while interacting
with union and intersection dynamic checks.

\subsection*{Flat contracts}

\unsure{Should we define contracts prior to this?}
User defined contracts, also called flat contracts, are a particular
kind of contract that behaves similar to an assertion, and whose
main point is to apply some arbitrary predicate (as arbitrary as the
host language allows it) to a value; if the predicate evaluates to
true, the contract passes, otherwise it fails.

For instance, we could define a flat contract \nickel{even} as
\nickel{fun x => x \% 2 == 0}, that checks
whether a number is even by checking the remainder of dividing it by 2.
And then use it to check that a function always returns an
even number, when applied to a \nickel{Integer}:

\begin{figure}[h]
\begin{center}
\begin{lstlisting}[language=nickel]
let f = (fun n => n * 2) @ (Integer -> even)
\end{lstlisting}
  \end{center}
\caption{A function wrapped with a contract stating that it always returns
an even number}
\label{fig:num-to-even}
\end{figure}

% $$let~f~=~(\lambda n. ~ n * 2)@(Number ~ \rightarrow ~ even?)$$

\unsure{Do we need deeper examples?
Maybe something showing that flat contracts could evaluate
a function.}

This kind of contracts are present on many different languages,
for instance, the Eiffel programming language, the precursor
of the Design by Contract ideals, allows to assert
these kinds of expression as pre- and post-conditions on
functions\cite{EiffelDesignByContract}.
A somewhat newer language, the D programming
language, allows, among other things, to have invariants on classes,
written with flat contracts, that are
dinamically checked at the frontiers of every public method \cite{DLangContracts}.

Finally, the Racket programming language also has a system to work with
contracts that allows to define flat contracts
\footnote{And a gradual typing system
built on top of that, but that goes beyond the scope of this
work.}
, and
to compose them with other kinds of dynamic checks,
like higher order contracts or a lightweight take on union
and intersection contracts\cite{RacketContracts}.
\todo{Talk about this, probably later on the paper.
See Related Works section}

Even if flat contracts may seem like too permissive, the ability to make
non trivial checks on values (to validate their output) is expected
by programmers on dynamic languages, where testing and runtime
assertions are a common pattern for safe programming, and
programmers are used to express complex predicates
over values.


\subsection*{Code manipulation (optimizations)}
\info{Present inlining and CSE as two major code
optimizations.
Purity and immutability as two important factors.}

The performance of modern programs heavily relies on non-trivial optimizations
performed by the compiler or the interpreter. Even more so for functional
languages, whose operational semantics is usually far removed from the actual
primitives of modern processors: naive execution can exhibit unacceptable
slowdowns. Functional programs tend to make heavy use of functions, and a
function call is a costly operation from the point of view of low-level
execution.

One crucial optimization is inlining(Figure~\ref{fig:optimizations-inlining-ex}). Inlining eliminates a function application
by directly substituting the function for its definition at compile time (or
before execution, for interpreted language). This is especially important for
small functions that are called repeatedly.

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elem = fun elt =>
  lists.any (fun x => x == elt) in

let subList = fun l1 l2 =>
  elem (lists.head l1) l2
  && subList (list.tail l1) l2
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let subList = fun l1 l2 =>
  lists.any (fun x => x == elt)
  && subList (list.tail l1) l2
\end{lstlisting}
  \end{center}
\caption{Inlining}
\label{fig:optimizations-inlining-ex}
\end{figure}

Another optimization is common subexpression elimination (CSE,
Figure~\ref{fig:optimizations-cse-ex}). CSE goes into the other direction: it
factors out equal subexpressions to avoid recomputing them multiple times.

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elemAtOrLast = fun index list =>
  if index > lists.length list - 1 then
    lists.elemAt (lists.length list - 1) list
  else
    lists.elemAt index list
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let elemAtOrLast = fun index list =>
  let l = lists.length list - 1 in
  if index > l then
    lists.elemAt l list
  else
    lists.elemAt index list
\end{lstlisting}
  \end{center}
\caption{Common subexpression elimination}
\label{fig:optimizations-cse-ex}
\end{figure}

Similar transformations exist beyond CSE, such as loop-invariant code motion or
some of Haskell's let-floating~\ref{}, which amount to hoist invariant
expressions out from repeated blocks in order to avoid recomputing them. In
particular, take the example of Figure~\ref{fig:optimizations-let-floating-ex}.

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let f = fun x => g y (x + 1)
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let g' = g y
let f' = fun x => g' (x + 1)
\end{lstlisting}
  \end{center}
\caption{Let-floating}
\label{fig:optimizations-let-floating-ex}
\end{figure}

The partial application \lstinline+g y+ is recomputed each time \lstinline+f+ is
called. This may be costly, in particular in the presence of contracts: if
\lstinline+y+ is a list for example, and \lstinline+g+ applies a list contract
on it, the penalty could be linear in the size of \lstinline+y+. A sensible
thing to do is to factor \lstinline+g y+ out of \lstinline+f+ as in
Figure~\ref{fig:optimizations-let-floating-ex}, which is something Haskell's
let-floating transformations could indeed do, given \lstinline+g+ is pure.

The soundness of these optimizations is tied the invariance of the semantics of
programs with respect to some substitutive transformations\todo{bad naming}.
Inlining requires that one can replace the application of a function by its
body: this is $\beta$-reduction, and it is hard to think of a language where it
is not a valid transformations. On the other hand, CSE-like transformations
require an expansion property of the form

$$M[N/x] \simeq let~x~=~N~in~M[x]$$

This equation clearly fails in a call-by-value language with side effects:

\begin{lstlisting}[language=Nickel]
let f x = print "hi";(x+1) in (f 1,f 1)
(*@ $\not \simeq$ @*) let f x = print "hi";(x+1) in
(*@ \phantom{$\not \simeq$} @*) let y = f 1 in (y,y)
\end{lstlisting}

However, this property does hold for \emph{pure} terms, that are terms without
side-effects. In a pure language, or a language with effect tracking like
Haskell\todo{Cite a different language, or remove citation}, pure terms can be
safely identified for applying optimizations. Other languages rely on
under-approximations.

\subsubsection*{Lazyness}
\unsure{Should we talk about lazyness?
this would be a good place to introduce it}

\unsure{Should we tease already here that unions and intersections break this
even for pure terms?}

\subsection*{Laziness}

\newpage

\section{Union \& intersection}
\info{What are they, what are they used for.}

Unions are useful as a fundamental data block.
Examples: nullable, tree-like data structure, multiple representations

\begin{lstlisting}[title={Tree-like data structure}]
type BinaryTree =
Integer | (BinaryTree, BinaryTree)
\end{lstlisting}

\begin{lstlisting}[title={Plain enumeration}]
protocol : `Http | `Ftp | `Sftp
\end{lstlisting}

\begin{lstlisting}[title={Nullable values}]
optionalValue : String | Null
\end{lstlisting}

\begin{lstlisting}[title={Alternative representations}]
person : {name : String, age : Int}
  | {name : String, dateOfBirth : String}
\end{lstlisting}


%   - Intersections are useful for subtyping or refinement (integers/floats
%       e.g)
\begin{lstlisting}[title={Value subtyping}]
1 : Int & Float
\end{lstlisting}
%   - Intersections are useful to encode overloading
\begin{lstlisting}[title={Overloading}]
incr: (Int -> Int) & (Float -> Float) =
  fun x => x + 1
\end{lstlisting}

%   - Intersections are useful to encode mixins (see Scala3)
\begin{lstlisting}[title={Structural mixins}]
Comparator: {cmp: T -> T -> Bool}
Shower: {show: T -> String}

showSmaller : (dict: Comparator & Shower) -> T -> T -> String
\end{lstlisting}
%   - Intersections appears in some form as unions' dual
\begin{lstlisting}[title={Intersection as the dual of unions}]
f : (Num | String) -> Bool
(*@ $\simeq$ @*) f : (Num -> Bool) (*@ $\cup$ @*) (String -> Bool)
\end{lstlisting}

\todo{Either here or the next section, show examples of unintuitive behaviour
of U and I. For example, I is not jos composition of contracts.
And union has to be treated as any one of the options}
% Things to settle: how to motivate them, how to compare them to ADTs. Purely
% dynamic approach, or typed approach too?

\newpage

\section{Issues coming from the semantics}
\info{What goes wrong or difficult when trying to implement union and
  intersection literally}

\newpage

\section{Issues in concrete restrictions from the literature}
\info{The various papers and the tradeoffs they make}

The papers that previously researched union and intersection
as dynamic checks have, in our eyes, different shortcomings
that makes them suboptimal solutions.

Starting with the Keil and Thiemann work \cite{KeilThiemannUnionIntersection},
they noticed that, since union contracts should share information between
different application contexts, while intersection contracts should behave
independently between each application context, the system becomes much
simpler if every contract gets transformed into a union of intersections
of other contracts, by using the usual De Morgan laws,
and then eagerly opening up unions, but postponing intersection
contracts as much as possible.
\todo{This assumes the difficulty has been previously explained}

For instance, if the value \nickel{V} is contracted with
\nickel{A /\\ (B \\/ C)}, then, before the contract is checked,
the contract gets opened up to something equivalent to
\nickel{(A /\\ B) \\/ (A /\\ C)}.

This straightforward solutions makes composing the Keil and Thiemann
system with other existing systems more difficult; in the words
of Williams, Morris, and Wadler:
"(...) the monitoring semantics for contracts of intersection and union types given by Keil
and Thiemann are not uniform. (...) If uniformity helps composition, then
special cases can hinder composition."\cite{RootCauseOfBlame}

Another difficult issue Keil and Thiemann were able to solve, is the
fact that flat contracts and intersection do not usually play nice
together.
\todo{This assumes the difficulty was already explained}
They provide two different sets of rules for their calculus,
the first one is non deterministic, whose purpose is to provide
semantics that are simple to understand.
The second one is a deterministic set of rules, that are intended
to be simple to implement.
This second set needs to perform operations
on the evaluation context, to decide whether or not to evaluate
a given contract.

We see two problems here, a minor one is the fact that two different
semantics need to be defined, which translates either to a difficult
to implement or a difficult to understand system.
A second, major one,
is the dependency added over the evaluation context, since, again,
it makes composing this, with other features desired on programming languages,
difficult, or even impossible (as the case with common subexpression elimination).

Williams, Morris, and Wadler, take a different approach on flat contracts,
they are completely forbidden in their system, explicitly to not encounter
the previously mentioned issue.
This restriction goes against what is usually expected from dynamic checks:
validation of data, and not just inclusion on types, is an expected
feature of contracts.

On top of that, a fundamental problem arises on said paper,
symptom of the difficulty of establishing good enough, and yet
simple semantics for union and intersection dynamic checks.
One of their main results, is the fact that their calculus, obeys
all of their expected monitoring properties for higher ordered, union
and, intersection contracts.
However, one of these properties states the following:

$$ K \in \llbracket A \cap B \rrbracket^- ~ if ~ K \in \llbracket A \rrbracket^- \lor K \in \llbracket B \rrbracket^- $$

Which means that a continuation ($K$) complies negatively with an
intersection of $A$ and $B$ if it complies negatively with at least one of these.
Altough this is true, it's a weaker statement of what we'd like to have,
since it rules out continuations like $(\lambda f.~(K_1[f],~K_2[f])) \square$,
where $K_1 \in \llbracket A \rrbracket^-$ but $K_1 \not \in \llbracket B \rrbracket^-$,
and dually for $K_2$, which would mean the continuation presented above would not
be in $\llbracket A \cap B \rrbracket^-$, even though our intuition (and the
introduction to the paper) indicates that it should.

While this mistake does not invalidate their work (the system they present
handles these cases correctly), it shows that existing research is still not on
good shape to handle the growing usecases being developed for
union and intersection around dynamic languages.

% $$ K ::= Id | K \bullet \square N | K \bullet V \square | K \bullet \square @^pA  $$

% Keil and Thiemann did noticed this problem, and their contract satisfaction
% rules only apply to elimination context, a particular kind of context
% where the hole is either being applied to an argument
% ($\square N$) or is used as an argument for a primitive
% operation ($O(\overrightarrow{\text{V}}, \square, \overrightarrow{\text{N}})$).



% K ::= Id | K ◦ □ N | K ◦ V □ | K ◦ □ @pA
\unsure{Is it worth mentioning how continuations are formed?
Should we go so techincal?}

\newpage

\section{Related work}
\info{Including a mention of statically typed systems with union}
\info{Include something about Racket's and and or contracts}

\newpage

\section{Conclusion}

\appendix

\section{Background on union types}

\subsection{Nickel design space}

{\color{red}Goals of the section

Introduce Nickel, explain the choice of gradual
typing and main design orientations, such as practice-oriented, lightweight,
etc.\vspace{0.5cm}}

Build systems, package managers, operating systems, cloud infrastructure,
continuous integration and web services\resolved{Also continuous integration}
are examples of modern complex software systems that require an extensive and
non-trivial configuration in order to make them adapted to each different
use-case. To manage the growing complexity that is then offloaded to
configurations, the declarative approach has become more and more popular,
illustrated for example by the infrastructure-as-code paradigm. This leads
configuration to play an important role in critical aspects of software
engineering, including security, availability, and maintainability.

However, static text-based configuration alone is falling short of
expressiveness, and is seldom sufficient. Data cannot be transformed, combined
nor shared, resulting at best in boilerplate and duplication of information, or
at worst, in data being invalid or inconsistent. Data validation is not
supported either, and must be handed over to yet another tool down the
configuration pipeline, if ever done. Correctly configuring a modern system is
hard and failures may have substantial negative consequences.

This is why the authors have been developing the Nickel
language\cite{NickelRepo}. Nickel is a configuration programming language,
meaning that a Nickel program evaluates to a value that must be
straightforwardly serializable to JSON, YAML or alike. Nickel aims at being
lightweight and easy to write while still providing features for writing correct
code and generating valid data. The focus is first and foremost practical:
Nickel originated as a rethink of the language of the Nix package manager, used
to describe one of the biggest sets of software packages\cite{repology}.  Nickel
targets build systems and cloud deployment tools (Kubernetes, Terraform or
NixOps) as well. While we are keen on incorporating existing or doing new
research when it solves a well-defined problem, the general design goals are
always guided by the practical industrial use cases.

\subsection{Typing}

Our aim is that writing simple Nickel feels as easy as writing JSON or YAML.
Unlike JSON, though, Nickel anticipates large configurations by being both
programmable and typed. In the configuration setting, there is a singular
dilemma with respect to typing: since a program is run on fixed inputs and is
expected to terminate, any relevant type error will show up at evaluation.  Why
bother with the complexity of a static type system? On the other hand, more and
more software systems offload complexity to configurations, in particular with
the infrastructure as code paradigm prevailing today in cloud deployment. When
the complexity of a codebase grows, static types become attractive again.  For
reusable code — that is, library functions —, static types are specifically
adapted, and bring all the usual benefits of early error detection, code
robustness, better code structure, documentation, and so on.

This dilemma is naturally solved by gradual typing\cite{Siek06gradualtyping}
which mixes both static and dynamic typing. Unlike gradually-typed languages
like TypeScript\unsure{Todo: explain that typescript uses unions as
  static typing whereas we are speaking of dynamic contracts}, we do not seek to build a complex type system that tries hard
to accept most of the idioms naturally arising in dynamically typed code.
Rather, we choose to provide a reasonably expressive type system with good
inference properties, which makes typing functions operating on generic data easy,
but may require using untyped code for more exotic expressions.  In any case,
this is not a surrender, as Nickel provides a complementary mechanism for more
advanced data validation: contracts.

\subsection{Contracts}
{\color{red}Goals of the section

A primer on contracts, which in the end are the problematic bit when confronted
with unions.\vspace{0.5cm}}

Enforcing pre- and post-conditions at runtime is a widely established practice.
In their foundational paper\cite{FindlerFelleisenHOContracts}, Findler and
Felleisen introduce a principled approach to run-time assertion checking that
nicely supports higher-order functions and introduces the notion of blame, which
is crucial to good error reporting. It became apparent later that their
contracts are closely related to the type casts introduced by gradual typing,
modulo blame: both \cite{FindlerMultiLang} and \cite{FelleisenInterLang} see the
value of contracts as a safe interface between typed and untyped code. In
\cite{WellTypedBlamed}, the authors precisely introduce a system integrating
gradual typing with contracts \textit{à la Findler \& Felleisen}.\unsure{The
historical bit should probably be moved to related works eventually} Nickel
adopts a similar type system, with both statically typed terms, dynamically
typed terms, and first-class contracts. In "first-class contracts", we include
the ability to write user-defined contracts. Because built-in types are too
simplistic for the purpose of data validation, the ability to write a small
validation function for, say, a port number, to have it immediately available as
a contract that can be composed with other type constructors\resolved{Needs code
to illustrate.}, is in our opinion one of the main appeal of Nickel's contracts
system. An example is given in Figure~\ref{fig:contract-composition}. The first
line defines a port contract from a predicate and use it in the definition of a
larger \lstinline+Configuration+ record contract. The \lstinline+Configuration+
contract checks that a value is a record with the following shape: it must have
a \lstinline+port+ field obeying the \lstinline+Port+ contract, and a
\lstinline+host+ field obeying a \lstinline+Host+ contract. It plays the role of
a \emph{schema}, used to validate the final data. The \lstinline+|+ operator
entails that a value respect a contract, akin to \lstinline+:+ for types. We
assume that a \lstinline+Host+ contract has been defined in a similar way.

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel]
let Port = contracts.fromPred (fun value =>
  builtins.isNum value && value % 1 == 0
  && value >= 0 && value <= 65353) in
let Configuration = {
  host | #Host,
  port | #Port,
} in
{host = "nickel-lang.org", port = 80}
| #Configuration
\end{lstlisting}
  \end{center}
\caption{Contract composition}
\label{fig:contract-composition}
\medskip
\small
Defines a port contract from a predicate and use it in the definition of a
\lstinline+Configuration+ record contract. \lstinline+Configuration+ plays the
role of a \emph{schema} for the final data. The \lstinline+|+ operator applies a
contract to a value, similar to `:` for static types. We assume that a
\lstinline+Host+ contract has also been defined.
\end{figure}

In this hybrid system, each type constructor of the static type system - arrows,
records, foralls - must have a contract counterpart that checks at run-time that
a value is a member of the corresponding type. Contracts for various
extensions of the simply typed $\lambda$-calculus have been investigated
\cite{BlameForAll, KeilThiemannUnionIntersection, RootCauseOfBlame,
DependentContracts, GradualTypingClasses}, with solutions of varying complexity.
Amongst all the common extensions to the polymorphic lambda calculus, one of the
most useful and widespread turns out to be one of the most challenging:
\emph{union types}.

\subsection{Union types}
{\color{red}Goals of the section

Introduce union in general, and most usual form in statically typed languages, tagged unions\vspace{0.5cm}}

Unions are fundamental and ubiquitous building blocks of program data. A union
only holds one value whose shape is only known to be in a fixed set of
alternatives: for example, either a boolean or a string. When used in combination
with products, they can represent arbitrary tree-like structures, allowing to
model a large class of data.

Unions are also useful for configurations:
\begin{itemize}
    \item To represent nullable values in JSON.
    \item For plain enumerations. For example, the enabled protocols of a data server
        would be either \lstinline+HTTP+, \lstinline+FTP+ or \lstinline+SFTP+.
    \item To support different representations of the same data. A file path could be
        accepted either as one string of \lstinline+"/"+-separated strings, or
        as a list of strings.
\end{itemize}

In statically typed languages, and more specifically in functional programming
languages, unions are usually implemented as algebraic data
types\unsure{This is a very misleading statement at best. Sums are
  "tagged union" sure, but that refers to an encoding a sums with
  unions, certainly not an encoding of unions with sums!} [references],
also called \emph{tagged unions}. Well-known programming languages with
first-class tagged unions include Haskell, OCaml, Rust, Scala, PureScript, Elm,
Swift and many more.

\subsection{Tagged versus untagged}
{\color{red}Goals of the section

Interpreted languages already need to tag their values, hence bare union are more natural.
It also corresponds better to prior usage in untyped code\vspace{0.5cm}}

In the statically typed setting, the actual representation of a tagged union is
an implementation detail: from the point of view of the programmer, a tagged
union is a first-class data type associated with constructors and destructors
with well-defined semantics. In contrast, in a gradually typed language like
Nickel, the question of the representation of tagged unions as untyped values
arises.

Unfortunately, tagged unions do not have a serializable canonical counterpart as
untyped data. One usual representation is a record with a tag and a value whose
shape depends on the tag (see Figure \ref{fig:union-encoding}).

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel]
{tag: <Num, Str>, value: Dyn}
\end{lstlisting}
  \end{center}
\caption{Encoding of the union type: integer or a string}
\label{fig:union-encoding}
\medskip
\small
In Nickel, \lstinline+<A, B, C>+ is the type of a C-like enumeration that can
take value \lstinline+A+, \lstinline+B+ or \lstinline+C+, while \lstinline+Dyn+
is the dynamic unitype.
\end{figure}

A better way to describe it would be as a dependent pair which first component
is a tag and second component is the data type corresponding to this tag:

\[
    \Sigma_{tag : <A, B, C>} \text{Alternative}(\text{tag})
\]

Nickel does not feature dependent types, which would open a whole new level of
complexity. Alas, choosing the non dependent representation as a default is not
fully satisfying.  First, it does not map precisely to a JSON value: in
consequence, a lot of illegal combinations are structurally valid as untyped
JSON values. But this is to be expected of any representation. More importantly,
this does not necessarily match with the configuration schemas one can find in
the wild, which favor simple, untagged union.

In dynamically typed languages, it is customary to directly store different kinds
of data in one variable without further ceremony. The runtime system needs to
attach type tags to values anyway, which can usually be observed using functions
like JavaScript's \verb+typeof+. Using so-called \emph{untagged
  unions}\unsure{If you can observe with typeof, then it's
  pretty much a tagged union, though the tag is implicit} has
already been an idiom in dynamically typed language for a long time
[ref/examples], and being able to type and handle these unions is an important
aspect of the migration to a gradual type system. Indeed, a lot of gradually
typed languages either existed originally as dynamically typed language or aim
at backward compatibility with a dynamically typed base language. This is why
they tend to favor supporting untagged union types, the typed counterpart of
this practice (as e.g in TypeScript \cite{TypeScriptUnions}).

In the case of Nickel, there is no pre-existing untyped language that we have to
support, so we are freer of our choice. However, Nickel is a configuration
language, whose contracts and types system is intended to be expressive enough
to encode data schemas encountered in the wild. Since these schemas do use
untagged unions, there is a strong incentive to support untagged unions at the
type level, or at least, at the contract level.

\subsection{Tagged as untagged}
{\color{red}Goals of the section

Untagged unions, modulo a slightly smarter typechecker, can encode usual type-safe
tagged unions. They let the user free of the representation though, and encode
more stuff, that's why they are appealing.\vspace{0.5cm}}

Untagged union, together with the other existing features of the type system,
are sufficient to implement the encoding illustrated in Figure
\ref{fig:union-encoding}. For example, let us represent an algebraic data type
(written in ML syntax) as an imaginary Nickel union type:

\begin{lstlisting}[language=caml]
type either = Left of float | Right of string
\end{lstlisting}

\begin{lstlisting}[language=nickel]
{ tag : <Left>, val : Num}
| { tag : <Right>, val : Str}
\end{lstlisting}

There is a twist, though. As it is, the static type system is unable to refine
the type of the value, making the following example rejected:

\begin{lstlisting}
switch x.tag {
  Left => x.val + 1,
  Right => strings.fromNum x.val
}
\end{lstlisting}

Flow typing, implemented in Racket\cite{FlowTypingRacket1, FlowTypingRacket2},
Groovy\cite{FlowTypingGroovy}, Whiley\cite{FlowTypingWhiley} or
TypeScript\cite{FlowTypingTypeScript}, is capable of refining appropriately the
type information in each branch. Thus equipped with untagged unions and a
typechecker smart enough, classic tagged unions can be simulated, but with the
additional benefit that the language is not imposing any representation.
Untagged unions empower the programmer to represent and handle a wider variety
of union idioms appearing in the wild.  Thus, adding union types to Nickel
sounds appealing.

\subsection{Union and intersections}
{\color{red}Goals of the section
Explain why having unions probably unavoidably leads one to have intersection.\vspace{0.5cm}}

While our original motivation is in supporting unions, the rest of the paper
explore complete systems featuring union and intersection types. One could
wonder if the difficulties could then be sidestepped by removing intesection out
of the equation. But

\begin{enumerate}
    \item Most of the encountered issues already appear with bare unions.
    \item Intersection being dual to unions, they are showing up in some way
        when unions are put in negative positions. For example, a contract for
        $(A \cup B) \to C$ in a system without intersections must be
        equivalent\unsure{``Must be'' is a rather strong statement, we
        will find a way to tone it down}
        to the contract $(A \to C) \cap (B \to C)$
\end{enumerate}

\unsure{Some bits missing so far: we are interested in higher-order
  contracts, Nickel is a higher-order \& pure language, contracts as
  functions. We've said that user-defined contracts are a thing, it
  probably matters so we may have to hammer it down.}

\unsure{Something that we must mention somewhere: if we want to check
  that something is a list of As lazily (to avoid making functions
  like hd be O(n), for instance), then we have a lot of the problems of
  higher-order contracts anyway.}

\subsection{Performance considerations}
\info{This a draft}
\todo{transition, location}

At first sight, performance should not be a critical issue given the use cases
of Nickel. But generating large configurations can already hit some limits in
current related languages [reference?]. A natural is parallelization:
Nickel being an almost pure functional programming language, evaluating separate
files or expressions in parallel is straightforward and effective. This
parallelization potential is thus a design requirement, and must be when the
addition of union types.

\section{Challenges}
\input{challenges}

\section{Current (Real life) implementations}

\info{The goal of this section is to outline existing languages that implement
union and intersection, in some form, and shortly compare these
with the semantics tried to obtain on research (WMW, KT)}

Unions and intersection are starting to become more and more common
on non-academic programming languages, as stated on the introduction,
unions are a natural abstraction for dynamic languages, where the type
of an expression could have many different shapes, without necessarily
having a mark to distinguish between them at type level.
With this in mind, a valid question is how do these languages solve the
union/intersection conundrum? Or, even better, what is it that they
solve?

In the rest of this section we revisit some different approaches.

\subsection{Racket}

Racket is a language based on Scheme, mainly thought as a language to experiment
with different language desings and ideas. It provides a very complete contract
system\cite{RacketContracts}.

Among those contracts, they provide \racket{and/c} and \racket{or/c} contracts.
These contracts are lightweight versions of intersections and unions, they simply
check that every contract is valid, in the case of \racket{and/c},
and that at least one contract
is valid, in the case of \racket{or/c}.

So, for instance, the usual usecase of intersection to encode bounded overloading
does not work on Racket. Take a look at the next example, the function
\racket{overload} should accept a call like \racket{(overload 3)}, but it fails
since 3 is not a valid \racket{string?}.

\begin{figure}[h]
 
\begin{lstlisting}[language=racket]
(define/contract overload
(and/c (-> number? number?)
       (-> string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{Non working function overloading on Racket.}

\end{figure}

Even worst, the \racket{or/c} contract doesn't allow to have multiple higher order
contracts that could (potentially) apply to a function, these have to be
differentiated by first order markers.
For instance, the code on Figure \ref{code:racket:or/c:working}
would correctly allow only to call
\racket{united} with a \racket{number?},
and it can make this distinction since it knows that
\racket{(lambda (x) x)} can not be a function that takes 2 parameters.
However, the code on Figure \ref{code:racket:or/c:non-working} would fail
before running, since the \racket{or/c} contract is unable to know
which of the two function contracts to use.
Ideally, this last example should just behave as wrapping
the function with the \racket{(-> even? even?)} contract.

\begin{figure}[h]
  
\begin{lstlisting}[language=racket]
(define/contract united
(or/c (-> number? number?)
      (-> string? string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{Working \racket{or/c} example on Racket.}
\label{code:racket:or/c:working}

\end{figure}

\begin{figure}[h]

\begin{lstlisting}[language=lisp]
(define/contract united
(or/c (-> number? number?)
      (-> even? even?))
(lambda (x) x))
\end{lstlisting}
\caption{Non working \racket{or/c} example on Racket.}
\label{code:racket:or/c:non-working}

\end{figure}


\unsure{This section is overall a bit hard to follow. I
  think I've figured out what it means, but it needs more love. Also
  give an example which doesn't work and one that does for or/c.}

\subsubsection*{case->}

Racket does provide an alternative for overloading methods, called the
\racket{case->} contract, however, this overloading of methods only
works over contracts of functions with different amount of parameters.
It's a good alternative to allow limited overloading of functions.
As an example, consider the following non failing piece of code, and
try to understand how Racket can decide, at each application,
which function contract to use.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract overcase
  (case-> (-> string? string?)
          (-> number? number? number?)
          )
  (lambda (x [y 0]) (if (number? x)
                   (+ x y)
                   x)))

(overcase 1 2)

(overcase "hello")
\end{lstlisting}
\end{figure}

\todo{Coming back to the problems of composing U/I with other typing
features, Racket has made a clear choice and decided that higher order
is more important (a wise decision)}

\subsection{Python - MyPy}

\unsure{We ought to group all the static typing in one subsection}

\bibliography{nickel}

\end{document}

% LocalWords:  Felleisen
