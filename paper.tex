\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\usepackage{amssymb}
\usepackage{mathtools,amsmath,amsfonts,amsxtra,amsthm,mathrsfs,mathpartir}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\usepackage{varioref}
\usepackage{verbatim,comment}
\usepackage{longtable}
\usepackage{tikz}
\usepackage{url}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}

\definecolor{OliveGreen}{RGB}{128,128,0}
%%%%%%%%%%%%%%%%% Editing marks %%%%%%%%%%%%%%%%%

  % TOGGLE ME to turn off all the commentary:
  \InputIfFileExists{no-editing-marks}{
    \def\noeditingmarks{}
  }

  \usepackage{xargs}
  \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
  % ^^ Need for pgfsyspdfmark apparently?
  \ifx\noeditingmarks\undefined
      \setlength{\marginparwidth}{1.2cm} % A size that matches the new PACMPL format
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
      \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
      \newenvironment{alt}{\color{red}}{}

      \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
      \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
      \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
      \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
      \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
      \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
  \else
  %    \newcommand{\Red}[1]{#1}
      \newcommand{\Red}[1]{{\color{red}{#1}}}
      \newcommand{\newaudit}[1]{#1}
      \newcommand{\note}[1]{}
      \newenvironment{alt}{}{}
  %    \renewcommand\todo[2]{}
      \newcommand{\unsure}[2][1=]{}
      \newcommand{\info}[2][1=]{}
      \newcommand{\change}[2]{}
      \newcommand{\inconsistent}[2]{}
      \newcommand{\critical}[2]{}
      \newcommand{\improvement}[1]{}
      \newcommand{\resolved}[2]{}
  \fi

%%%%%%%%%%%%%%%%% /Editing marks %%%%%%%%%%%%%%%%%

%%%%%%%%%%% LST listing confinguraiton %%%%%%%%%%%

\lstdefinelanguage{nickel}{
    keywords=[1]{
      if,
      then,
      else,
      switch,
    },
    keywords=[2]{
      let,
      rec,
      fun,
      in
    },
    keywords=[3]{
      forall,
    },
    keywordsprefix=\#,
    keywords=[4]{
      true,
      false,
      null
    },
    keywords=[5]{
      doc,
      default,
    },
    sensitive=true, % keywords are case-sensitive
    morecomment=[l]{//}, % l is for line comment
    morecomment=**[is][\color{gray}]{\$}{\$},
    morestring=[b]", % defines that strings are enclosed in double quotes
    morestring=[s]{m\#"}{"\#m},
    moredelim=[is][\color{gray}]{\$}{\$},
    literate=
        *{->}{$\rightarrow$}1
        {...}{\ldots}1
        {@&}{$\cap$}1
        {@|}{$\cup$}1
        {=>}{$\Rightarrow$}1
        {>=}{$\geq$}1
        {<=}{$\leq$}1
} %

% Copied from https://hal.inria.fr/hal-01140459/file/racket.inc.tex
\lstdefinelanguage{racket} {
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    define-context, define-controller, Integer, Boolean, get, when-required, when-provided,
    maybe_publish, require, submod, or/c, and/c, ->, \#\%module-begin,
    always_publish, with-syntax, define-struct/contract, syntax-case,
    define/contract,
    let-values, let*-values,
    module, provide,
    and, or, not, delay, force,
    \#`, \#',
    \#lang, implement, begin-for-syntax, rename-out,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsoletter={',`,-,/,>,<,\#,\%},
  morecomment=[l]{;},
%  literate={lambda}{{\lambdaup}}1, % lambda -- look at https://tex.stackexchange.com/questions/119879/math-symbols-in-tt-font
  moredelim=**[is][\color{light-gray}]{<<@<<}{>>@>>},
  moredelim=**[is][\itshape\color{OliveGreen}]{<<;<<}{>>;>>},
  morecomment=[s]{\#|}{|\#},
  sensitive=true,
}

% Copied from https://tex.stackexchange.com/questions/89574/language-option-supported-in-listings
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  % keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  % stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{Python}{
  % keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  % keywordstyle=\color{blue}\bfseries,
  % ndkeywords={class, export, boolean, throw, implements, import, this},
  % ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  % comment=[l]{//},
  % morecomment=[s]{/*}{*/},
  % commentstyle=\color{purple}\ttfamily,
  % stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  language={nickel},
  basicstyle=\small\ttfamily, % Global Code Style
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=2, % number of spaces indented when discovering a tab
  columns=fixed, % make all characters equal width
  keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
  showstringspaces=false, % lets spaces in strings appear as real spaces
  breaklines=true, % wrap lines if they don't fit
  frame=trbl, % draw a frame at the top, right, left and bottom of the listing
  frameround=tttt, % make the frame round at all four corners
  framesep=4pt, % quarter circle size of the round corners
  numbers=left, % show line numbers at the left
  numberstyle=\tiny\ttfamily, % style of the line numbers
  escapeinside={(*@}{@*)} % escape sequence to insert latex
  % commentstyle=\color{dark-grey}, % style of comments
  % keywordstyle=[1]\color{blue-portage}, % style of keywords
  % keywordstyle=[2]\color{orange-vivid-tangerine}, % style of keywords
  % keywordstyle=[3]\color{blue-portage}, % style of keywords
  % keywordstyle=[4]\color{green-pea}, % style of keywords
  % keywordstyle=[5]\color{pink-froly}, % style of keywords
  % stringstyle=\color{blue-marguerite}, % style of strings
}

\lstset{
  escapeinside={(*@}{@*)} % escape sequence to insert latex
}
\newcommand{\nickel}[1]{\lstinline[language=nickel]{#1}}
\newcommand{\racket}[1]{\lstinline[language=racket]{#1}}
\newcommand{\haskell}[1]{\lstinline[language=Haskell]{#1}}
\newcommand{\typescript}[1]{\lstinline[language=JavaScript]{#1}}
\newcommand{\python}[1]{\lstinline[language=Python]{#1}}

\bibliographystyle{ACM-Reference-Format}

\begin{abstract}
This paper reports an attempt to incorporate union and intersection types in
Nickel, a configuration programming language with a gradual type system and
first-class contracts. While the end result looks appealing, it turns out the
concrete impact on both the design and the implementation of the language is
unexpectedly high. We review the issues raised in particular by the
implementation of contracts for unions and intersections, and why we think the
cost ends up too high for the benefit. We conclude by suggesting different leads
to represent and type unions.
\end{abstract}


\title{Union and intersection contracts are hard, actually}
\author{Teodoro Freund}
\affiliation{
  \institution{Universidad de Buenos Aires}
  \city{Buenos Aires}
  \country{Argentina}
}
\email{tfreund95@gmail.com}

\author{Yann Hamdaoui}
\affiliation{
  \institution{Tweag}
  \city{Paris}
  \country{France}
}
\email{yann.hamdaoui@tweag.io}
\author{Arnaud Spiwack}
\affiliation{
  \institution{Tweag}
  \city{Paris}
  \country{France}
}
\email{arnaud.spiwack@tweag.io}

\begin{document}

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10002944.10011122.10002945</concept_id>
       <concept_desc>General and reference~Surveys and overviews</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011024</concept_id>
       <concept_desc>Software and its engineering~Language features</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011074.10011099</concept_id>
       <concept_desc>Software and its engineering~Software verification and validation</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[300]{General and reference~Surveys and overviews}
\ccsdesc[500]{Software and its engineering~Language features}
\ccsdesc[300]{Software and its engineering~Software verification and validation}

\keywords{contracts, higher-order contracts, union, intersection}

\maketitle

\section{Introduction}
\label{sec:intro}

Union types, meaning a type \nickel{A @| B} containing values which
belong either to a type \nickel{A} or \nickel{B}, are a popular tool
when adding a static types to a dynamic language. In particular, both
TypeScript~\cite{TypeScriptUnions} and MyPy~\cite{MyPyOptional}, use
union types to model the frequent practice to use the value
\typescript{null} (\python{None} in Python) to represent an absent
optional value. This is why the gradual typing literature, concerned
with formalising the interplay between static and dynamic type
systems, has been quite interested in union
types~\cite{RootCauseOfBlame,KeilThiemannUnionIntersection}.

On the other hand, unions are not a common feature of static type
systems, mostly because they are quite difficult to verify
statically. So unions are really only worth it in gradually typed
language where they formalise existing dynamically typed patterns. On
the other hand, surely, for dynamic tests, unions are really easy: it
is simply the Boolean disjunctions of two tests.

Unfortunately, as we document in this article, as soon as you extend
dynamic checks to \emph{contracts}~\cite{FindlerFelleisenHOContracts},
unions become actually pretty difficult, and threaten desirable
properties of your language.

\subsection{Configuration languages}

To motivate contracts and the problem caused by unions, let's make a
detour through configuration languages.
%
A configuration language is a language concerned with describing the
configuration of an application. In traditional configuration
languages, such as YAML, TOML, or JSON, the configuration is fully,
and explicitly, spelt out.

However, with the advent of DevOps, configurations have been extended
to describe the entire state of a computer, or even a fleet of
computers. For instance, with Kubernetes you need to configure a large
fleet of (possibly replicated) docker containers. To describe this
sort of configurations, you really want to be able to re-use and
abstract parts of the configuration, like traditional programming
languages do. To meet this need, languages such as Cue~\cite{cueLang},
Dhall~\cite{dhallLang}, Jsonnet~\cite{jsonnetLang}, or Nickel~\cite{NickelRepo}, where
configurations are generated rather than spelt out, were created.

Another example is continuous integration systems: it's fairly typical
to need a matrix of jobs, wherein the same tests are run on different
infrastructures, or with different versions of a compiler. Traditional
configuration would have you copy the same steps for each
infrastructure. This is tedious, hard to maintain, and error
prone. It's much better, instead, to write the steps once, and
instantiate them for each infrastructure. Continuous integration
systems typically do this using a templating system layered on top of
YAML. Each of the configuration-generating languages above allow such
job-matrix definition natively.

\subsection{Nickel}

In this article, we will use the Nickel language~\cite{NickelRepo} as
illustration and motivation. At its core, Nickel is the JSON data
model, that is dictionaries (written \nickel{\{field1 = value1, ...,
  fieldn = valuen\}}) and arrays (\nickel{[x1, ..., xn]}), augmented
with functions (\nickel{fun arg1 ... argn => body}) and
let-definitions (\nickel{let id = value in exp}).\unsure{Arnaud: this
  paragraph looks kind of bad, maybe it'll be better to put each
  syntax entry in an enumeration, we will see if there is still room
  for this}

A Nickel configuration is then evaluated to an explicit configuration,
\emph{e.g.}  in JSON, which can then be consumed by an
application. Therefore a design constraint of Nickel is any Nickel
data must have a straightforward interpretation in JSON.

\subsection{Contracts}

A useful feature of a configuration language is to provide facilities
for schema validation. That is, help answer questions like: does our
configuration have all the required fields? does the \nickel{url} field indeed
contains a URL?

These are inherently dynamic questions, as they are all questions
about the evaluated configuration. To this effect, Nickel lets us
annotate any expression with a dynamic schema check: \nickel{exp |
  C}. There is also syntactic sugar to annotate definitions:
\nickel{let id | C = value in exp} stands for \nickel{let id = (value
  | C) in exp}.\unsure{This point used to be made, do we want to
  reinsert it? However, Nickel programs are of a special kind: they are usually
simple, terminating programs that run on fixed inputs. Correctness errors will
show up at evaluation anyway, or will not matter (dead code).}

Let us pause for a moment and consider the following: it is Nickel's
ambition to be able to manipulate configurations like Nixpkgs. With
over 50\,000 packages, is one of the largest repository of software
packages in existence~\cite{repology}. Concretely, Nixpkgs is a
dictionary mapping packages to build recipes. That is, a massive,
over-50\,000-key-value-pair wide dictionary. It is absolutely out of the
question to evaluate the entirety of this dictionary every time one
needs to install 10 new packages: this would result in a painfully
slow experience.

To be able to support such large dictionaries, Nickel's dictionaries
are \emph{lazy}, that is, the values are only evaluated when
explicitly required. For instance, when writing
\hbox{\nickel{nixpkgs.hello},} only the \nickel{hello} package gets
evaluated.

But let's consider now writing something like \nickel{nixpkgs |
  packages}, to guarantee that all the packages conform to the desired
schema. If this were a simple Boolean test, it would have to evaluate
all 50\,000 package to check their validity, hence breaking the
laziness of dictionaries. Do we have to choose between laziness and
schema validation? Fortunately, we don't! Enter
\emph{contracts}~\cite{FindlerFelleisenHOContracts}: dynamic check
which can be partially delayed, yet errors can be reported
accurately. Contracts can respect laziness of dictionaries, and they
can be use to add schema validation to functions as well (in fact
functions were the original motivation for contracts).

There is no Boolean function which can check that a value has type
\nickel{Str -> Str}. Instead, a contract for \nickel{Str -> Str}
checks for each call of the function whether
\begin{enumerate}
\item the argument has type \nickel{Str}, otherwise the caller of the
  function is faulty
\item if so, that the returned value has type \nickel{Str}, otherwise
  the implementation of the function is faulty
\end{enumerate}

Like in the case of lazy dictionaries, the checks are delayed.
Contracts keep track of whether the caller or the implementation is
at fault for a violation, hence it can report precise error
messages. Compare Figure~\ref{fig:contract-reporting-wo} and
Figure~\ref{fig:contract-reporting-w}: in
Figure~\ref{fig:contract-reporting-wo} an error is reported inside the
\nickel{catHosts} function, but \nickel{catHosts} is, in fact,
correct, as is made clear by Figure~\ref{fig:contract-reporting-w},
where \nickel{catHosts} is decorated with the \nickel{Str -> Str}
contract, and correctly reports that the caller failed to call
\nickel{catHosts} with a string argument.

\begin{figure*}
  \centering
  \begin{subfigure}[b]{0.48\linewidth}
    \begin{lstlisting}[language=nickel]
let catHosts = fun last =>
  let hosts = ["foo.com", "bar.org"] in
  lists.fold (fun val acc => val ++ "," ++ acc) hosts last in

let makeHost = fun server ext =>
  server ++ "." ++ ext in

catHosts (makeHost "google")
\end{lstlisting}

    \begin{lstlisting}[frame=none,numbers=none, basicstyle=\footnotesize\ttfamily]
error: Type error
3 | [(*@{\ldots}@*)] "," ++ acc) hosts last in
  |            ^^^
  | This expression has type Fun,
  | but Str was expected
4 |
5 | let mkHost = fun server ext => [(*@{\ldots}@*)] in
  |              -----------------------
  |              evaluated to this
  = ++, 2nd argument
\end{lstlisting}
    \caption{Error reporting without contract}
    \label{fig:contract-reporting-wo}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.48\linewidth}
    \begin{lstlisting}[language=nickel]
let catHosts | Str -> Str = fun last =>
  [(*@{\ldots}@*)]
\end{lstlisting}
\vspace{10ex}
    \begin{lstlisting}[frame=none,numbers=none, basicstyle=\footnotesize\ttfamily]
error: Blame error: contract broken by the caller.
  |  Str -> Str
  |  --- expected type of the argument [(*@{\ldots}@*)]
[(*@{\ldots}@*)]
1 | let catHosts | Str -> Str = fun last =>
  |                ^^^^^^^^^^ bound here
[(*@{\ldots}@*)]
6 | catHosts (makeHost "google")
  | --------------------------- (2) calling <func>
    \end{lstlisting}
    \caption{Error reporting with contract}
    \label{fig:contract-reporting-w}
  \end{subfigure}
  \caption{Contracts improve error messages}
\end{figure*}

Unfortunately, the delayed check of contract, while essential to
ensuring that schema validation doesn't affect performance (or, indeed,
is possible at all on functions), make union contracts (and their less
appreciated sibling, intersection contracts) quite problematic.

\subsection{Structure of this paper}
\unsure{Make this section into a contributions section?}
Section~\ref{sec:intro} introduced the perspective of designing a configuration
language. We presented the concept of contracts and detailed why contracts are
particularly fitted for a configuration language, and more generally for data
validation or program correctness in a dynamically typed language. The rest of
the paper is structured as follows:
\begin{itemize}
    \item Section~\ref{sec:feat-lang} outlines various common features of
        programming languages that may interact in a bad way with union and
        intersection contracts.
    \item Section~\ref{sec:union-inter} introduces unions and intersections and
        lists the possible motivations for adding them to a language.
    \item Section~\ref{sec:issues-sem} studies intrinsic difficulties one may
        encounter when trying to implement union and intersection contracts in
        practice.
    \item Section~\ref{sec:issues-literature} presents the shortcomings found in
        existing attempts to solve said difficulties.
    \item Section~\ref{sec:related-work} provides some related work.
\end{itemize}

Section~\ref{sec:conclusion} concludes the paper.


\section{A typology of language features}
\label{sec:feat-lang}

Union contracts are not only difficult to implement, their
unrestricted presence is incompatible with potentially desirable
properties of the language. In this section we present some of these
properties; we will show how these properties interact with union
contracts in Sections~\ref{sec:issues-sem}
and~\ref{sec:issues-literature}.

\subsection{User-defined contracts}
\label{sec:flat-contracts}

A strength of dynamic checking is that we can easily check properties which
are impractical to check statically. For instance that a string
represents a well-formed URL, or a number is a valid port.

This same property is desirable of contracts as well, otherwise we
lose an important benefits of dynamic checking. Preferably, we want to
be able to extend the universe of contracts with user-defined
predicates (sometimes called flat contracts).

For instance, Figure~\ref{fig:port-contract} shows the definition of a
contract for valid ports in Nickel syntax.
%
User-defined contracts can be combined with other contracts normally:
\nickel{Int -> Port} is a contract verified by functions
which, given an integer returns a valid port.


\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel]
let Port = contracts.fromPred (fun p =>
  num.isInt p && 0 <= p && p <= 65535) in
80 | Port
\end{lstlisting}
\end{center}
\caption{A contract for valid ports}
\label{fig:port-contract}
\end{figure}

This type of contracts are present in many different languages,
for instance, the Eiffel programming language\cite{meyer1987eiffel}, the precursor
of the Design by Contract philosophy, makes it possible to assert
these kinds of expression as pre- and post-conditions on
functions and as invariants on classes\cite{EiffelDesignByContract}.

The Racket programming language also has a system to work with
contracts, powerful enough to define flat contracts, and
to compose them with other kinds of dynamic checks,
like higher order contracts or a lightweight take on union
and intersection contracts\cite{RacketContracts}.


\subsection{Purity}
\label{sec:optimizations}

\unsure{I (Arnaud) changed the title of this subsection. Maybe it's
  not the best one, but if it is, then we ought to reorder the section
  a little bit to fit the modified narrative.}

The performance of modern programs heavily relies on the optimizations performed
by the compiler or the interpreter. Even more so for functional languages, whose
execution model is often far removed from actual processors, causing naive
execution to exhibit unacceptable slowdowns.

One crucial optimization is
inlining (Figure \ref{fig:optimizations-inlining-ex}). Functional programs tend
to make heavy use of functions, and a function call is a costly operation from
the point of view of low-level execution. Inlining eliminates a function
application by directly substituting the function for its definition at compile
time (or before execution, for interpreted language). This is especially
efficient for small functions that are called repeatedly.

\info{I think it's better to use [h] on figures, we can discuss it}
\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elem = fun elt =>
  lists.any (fun x => x == elt) in

let subList = fun l1 l2 =>
  elem (lists.head l1) l2
  && subList (list.tail l1) l2
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let subList = fun l1 l2 =>
  lists.any (fun x => x == (lists.head l1)) l2
  && subList (list.tail l1) l2
\end{lstlisting}
  \end{center}
\caption{Inlining}
\label{fig:optimizations-inlining-ex}
\end{figure}

While inlining expands an expression by substituting a definition for its value,
an opposite transformation is sometimes beneficial, for example when a composite
expression is repeated several times. This causes the same expression to be
wastefully recomputed at each occurrence. Common subexpression elimination (CSE)
consists in introducing a new identifier for this expression and using the
identifier in place of the original occurrences
(Figure \ref{fig:optimizations-cse-ex}), computing the result once and for all.

\begin{figure}[h]
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let elemAtOrLast = fun index list =>
  if index > lists.length list - 1 then
    lists.elemAt (lists.length list - 1) list
  else
    lists.elemAt index list
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let elemAtOrLast = fun index list =>
  let l = lists.length list - 1 in
  if index > l then
    lists.elemAt l list
  else
    lists.elemAt index list
\end{lstlisting}
  \end{center}
\caption{Common subexpression elimination}
\label{fig:optimizations-cse-ex}
\end{figure}

Beyond CSE, optimizations such as loop-invariant code motion or
let-floating~\cite{letFloating} apply the same principle of extracting out an invariant
expression to avoid its recomputation respectively across loop iterations and
function calls.

\begin{figure}
  \begin{center}
\begin{lstlisting}[language=nickel,title={Source program}]
let f = fun x => g y (x + 1)
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Optimized program}]
let g' = g y
let f' = fun x => g' (x + 1)
\end{lstlisting}
  \end{center}
\caption{Let-floating}
\label{fig:optimizations-let-floating-ex}
\end{figure}

For example, take the code of Figure~\ref{fig:optimizations-let-floating-ex}.
The partial application \lstinline+g y+ is recomputed each time \lstinline+f+ is
called. This may be costly, in particular in the presence of contracts: if
\lstinline+y+ is a list for example, and \lstinline+g+ applies a list contract
on it, the cost could be linear in the size of \lstinline+y+. A sensible thing
to do is to factor \lstinline+g y+ out of \lstinline+f+ as in
Figure~\ref{fig:optimizations-let-floating-ex}, which is something a
let-floating transformation could indeed do (given \lstinline+g+ is pure, as
explained below).

The soundness of all these optimizations is tied to the invariance of the
semantics of programs with respect to specific substitutions. Inlining requires
that one can replace the application of a function by its body, which is
basically $\beta$-reduction: as long as the arguments are evaluated following
the language's strategy, it is a valid transformation. On the other hand,
a CSE-like transformation on a term $M$ requires an expansion property of the form

\begin{equation}\label{eq:cbn-expansion}
M[x/N] \simeq let~x~=~N~in~M
\end{equation}

Here, $M[x/N]$ is the substitution of $x$ for $N$ in the term $M$.
\ref{eq:cbn-expansion} has an evident call-by-name flavour, and consequently
fails in general for a call-by-value language with side effects.  Indeed, define
the following function $f$:

\begin{lstlisting}[language=Nickel]
let f x = print "hi";(x+1) in
\end{lstlisting}

Then:

\begin{lstlisting}[language=Nickel]
(f 1,f 1) (*@ $\not \simeq$ @*) let y = f 1 in (y,y)
\end{lstlisting}

In the example above, the first term prints \nickel{"hi"} two times while the
second term prints it only once. However, \ref{eq:cbn-expansion} does hold for
\emph{pure} terms, that are terms without side-effects. In a pure language, or a
language with effect tracking like Haskell\todo{Cite a different language, or
remove citation}, pure terms can be safely identified for applying
optimizations.

Strikingly, we will see in section~\ref{sec:issues-sem} that the introduction of
unions and intersections can make \ref{eq:cbn-expansion} unsound
\emph{even in a pure setting}, making the optimization of
Figure~\ref{fig:optimizations-let-floating-ex} unsound in general.


\section{Union \& intersection}
\label{sec:union-inter}

Let us now consider union and intersection contracts, before we
explain, in Section~\ref{sec:issues-sem} how they can compromise the
properties that we described in Section~\ref{sec:feat-lang}.

\subsection{Unions}

A union type \nickel{A @| B} is a type of values which are either of
type \nickel{A} or of type \nickel{B}: literally the union of
\nickel{A} and \nickel{B}. Union types are popular in gradual typed
systems such as TypeScript~\cite{TypeScriptUnions} and
MyPy~\cite{MyPyOptional}.

\paragraph{In gradually typed systems}

The problem that these practical gradual type systems are trying to solve is to
capture, in static types, as many programming patterns as possible
from the underlying dynamically typed language (JavaScript for
TypeScript and Python for MyPy). One such pattern is
heterogeneous collections. For instance, in TypeScript, an array
which can contain both strings and numbers would have type
\typescript{Array<string|number>}.

A probably even more common pattern is a variable which can contain
either a value of type a (say, a number) or the \typescript{null}
value. So much so, in fact, that MyPy defines a type alias
\python{Optional[A]} for \python{Union[A,None]} (\python{None} is how
Python renders the null value).

Yet another application of union types is, rather than capturing a
pattern from JavaScript or Python, to capture a pattern from
traditional statically typed language: sum types. In statically typed
languages, values of sum types are usually thought of as being built
out of constructors. But neither JavaScript nor Python have such
constructors. So instead, sums are construed as ``tagged unions'' (or
discriminated unions), that is, quite literally, the union of two
types which contain a discriminating tag. See
Figure~\ref{fig:tagged-union} for an example from the TypeScript
documentation: there the \typescript{kind} field is the tag, and its
type in both alternatives is a singleton type which contains only the
specified string.

\begin{figure}
  \centering
  \begin{lstlisting}[language=JavaScript]
    interface Circle { kind: "circle"; radius: number; }

    interface Square { kind: "square"; sideLength: number; }

    type Shape = Circle | Square;
  \end{lstlisting}

  \caption{A sum type as a tagged union}
  \label{fig:tagged-union}
\end{figure}

\paragraph{Union contracts}

In the academic gradual type literature, it is common to use contracts
as a glue between static and dynamic types. Therefore, the question of
bringing union to contracts is natural, and have indeed been studied
(\emph{e.g.}~\cite{KeilThiemannUnionIntersection,RootCauseOfBlame}).

Like for static types, a valid value for the contract \nickel{A @| B}
is a value which is valid either for contract \nickel{A} or for
contract \nickel{B} (though in Section~\ref{sec:issues-literature} we
will see that it may be desirable to weaken this definition).

Nickel is a language built from scratch with contracts, so it may be
less clear why unions are useful. However, Nickel's ambition is to
have its data model canonically interpretable in common serialization
formats, in particular JSON. It means that it is very convenient to
represent optional value by the \nickel{null} value like in
JavaScript. It also means that Nickel doesn't have built-in
constructors: constructors don't have a canonical representation in
JSON. So it would be quite natural to represent optional contracts and
sum contracts as unions.

% Arnaud: I'm not deleting this quite yet because we may want to use
% these examples, I just didn't manage to make them fit in the flow of
% the narrative.
%
% Unions are not only useful to model the outcome of alternative
% branches of computations, but they can be used to
% formalize very common patterns of data types:
% \begin{itemize}
%     \item To represent nullable, or optional, values.
% \begin{lstlisting}[language=nickel]
% optionalValue | Str @| Null
% \end{lstlisting}

%     \item For plain enumerations of literals.
% \begin{lstlisting}[language=nickel]
% protocol | "Http" @| "Ftp" @| "Sftp"
% \end{lstlisting}

%     \item To support different representations of the same data.
% \begin{lstlisting}[language=nickel]
% person | {name : Str, age : Int}
%   @| {name : Str, dateOfBirth : Date}
% \end{lstlisting}

% \end{itemize}
% All of which are common in configurations.

\unsure{Arnaud: this paragraph is pretty good, on the other hand, there
is no value which lets me complete the example, so this example falls
a bit flat.}
We have shown how values of a union are built, is worth mentioning
how they are used.
For instance, consider the TypeScript function on Figure \ref{fig:addElem},
we want it to insert an element to a list that is either an
\typescript{Array<string>} or an \typescript{Array<number>},
what value could we fill \typescript{...} with for this to typecheck?
Since we don't know what's the shape of \typescript{list},
we can't know whether to push a \typescript{string} or a
\typescript{number}.
That is, when using a union, we have to treat it as if it where any one
of the alternatives, in the case of the example, we should provide
it with a value that is both a \typescript{string} and a \typescript{number}.

\begin{figure}[h]
\begin{lstlisting}[language=JavaScript]
function addElem(list: Array<string> | Array<number>) {
  list.push(...)
}
\end{lstlisting}
\caption{Adding an element to a union of two arrays}
\label{fig:addElem}
\end{figure}



\subsection{Intersections}

An intersection type \nickel{A @& B} validates values which are both
valid for contract \nickel{A} and contract \nickel{B}.

Intersection contracts (and types) are probably less prevalent than
union in practical type systems. However, a function from a union is
equivalent to an intersection. That is \nickel{(A @| B) ->
  C}$\simeq$\nickel{(A -> C) @& (B -> C)}. So in a system with
functions and unions, intersections are already morally present (and,
for that matter, in a system with functions and intersections, unions
are morally present). Some
of our examples in Sections~\ref{sec:issues-sem}
and~\ref{sec:issues-literature} are better expressed in terms of
intersections, so it's best to include them.

Yet intersections are useful in their own right. They can be used to
combine dictionaries in the style of object-oriented inheritance. For instance, in
Figure \ref{fig:intersection-record} two types are defined
\nickel{Animal} and \nickel{Pet}, and a variable that is compatible
with both types is declared, with type \nickel{Animal @& Pet}. This
particular application is supported, for instance, by TypeScript.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let Animal = { species: Str, race: Str } in
let Pet = { owner: Str, name: Str } in
let myDog | Animal @& Pet =
  { species = "Canis Lupus",
    race = "Australian Cattle Dog",
    owner = "Anonymous Author",
    name = "Juno" }
\end{lstlisting}
\caption{An animal that is also a pet}
\label{fig:intersection-record}
\end{figure}

Another application of intersections shows up when intersecting
functions: it can be used to encode overloading.
For instance, take a look at Figure~\ref{fig:intersection-overloading-ex}, where the function
\nickel{duplicate} works both as a function to duplicate
arrays, as well as a function to duplicate strings.
This is particularly useful when using unions, since it's a
good way to express that a function can deal with different
shapes of data.
For instance, in the same figure, \nickel{duplicate} is (correctly) called
on a value of type \nickel{[String] @| String}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let duplicate
    | (List String -> List String)
    @& (String -> String) =
  fun x => x ++ x in
let text | [String] @| String = ... in
duplicate text
\end{lstlisting}
\caption{Duplicating an array of Strings or a String}
\label{fig:intersection-overloading-ex}
\end{figure}

\section{Incompatibilities}
\label{sec:issues-sem}

However appealing union and intersection contracts may be, they happen
to be fundamentally incompatible with the desirable language
features from Section~\ref{sec:feat-lang}. At least in there
full-blown form: in Section~\ref{sec:issues-literature} we will
discuss pragmatic restrictions of union and intersection contracts to
recover some or all of the features.

\subsection{Union contracts as a side-effect}

In Nickel, the failure of a function contract can always be traced back to a
single call. For example, take the function \nickel{f} with a simple contract
attached of Figure~\ref{fig:pos-to-pos}. The whole program fails with a contract
error blaming \nickel{f} because the return value of the second call \nickel{f 5}
violates the \nickel{Positive} contract. The first call to \nickel{f} does
not matter, and \nickel{f 5} is a single and independent witness of the contract
violation. The user is pointed to this one location in practice.

This single witness property can be justified as follows. Apart from the error
reporting part (although this is the crucial bit in practice!), the current
contract system of Nickel can be implemented purely as a library, requiring only
a \nickel{fail} primitive to abort the execution. In practice, applying a
function contract to \nickel{f} replaces it with a \nickel{f'} that performs the
additional checks. Thus, since the core language is pure (albeit
partial, if only because \nickel{fail}), the failure of \nickel{f' 5}
must be independent of its environment and of any previous call to \nickel{f'}.

% When programming with dynamic checks it is assumed that lack of
% failure does not mean that the program works perfectly.
%
% For instance, imagine having a function wrapped in a contract
% that checks that it maps positive numbers to positive numbers,
% and using it in different ways,
% like the program on Figure \ref{fig:pos-to-pos}.
% Clearly, there is an error on this program, but if the first call
% to \nickel{f} that gets executed is \nickel{f 10}, the error will not
% be found at that point, and the first operand of the addition would be
% evaluated to \nickel{3}.
% If, later on, \nickel{f 5} gets executed, the contract would get violated,
% since \nickel{f} gets called with a positive value, but returns a negative
% one (\nickel{-2}).

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f | Positive -> Positive
      = fun x => x - 7 in
(f 10) + (f 5)
\end{lstlisting}
\caption{Simple contract violation}
\label{fig:pos-to-pos}
\end{figure}

% Even if the program performed two different applications of \nickel{f}
% before finding the contract violation, the first one is not actually
% needed, and executing only \nickel{f 5} is enough to find the problem.
%
% Having a witness of size 1 for every contract failure is a really nice to have property
% since it means, for example, that every time that a contract is violated,
% the stack trace is enough to understand how it was violated, and to potentially
% come up with a minimal example that breaks the contract.
% However, when unions get introduced, this property is lost.

Union contracts are different. Consider the program presented in
Figure~\ref{fig:wrong-union-function}. The same \nickel{f} is now given a union
contract. \nickel{f} is violating this contract once again, as it neither maps
positive numbers to positive numbers nor positive numbers to negative numbers.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f | (Positive -> Positive)
        @| (Positive -> NonPositive)
      = fun x => x - 7 in
(f 10) + (f 5)
\end{lstlisting}
\caption{Union contract violation}
\label{fig:wrong-union-function}
\end{figure}

This program must fail, because \nickel{f 10} is a witness of \nickel{f} failing
the contract \nickel{Positive -> NonPositive}, and \nickel{f 5} is a witness of
\nickel{f} failing \nickel{Positive -> Positive}.  But, as opposed to the
example from Figure~\ref{fig:pos-to-pos}, removing only one of the calls makes the
program succeed! Indeed, each call only unveils the violation of one component
of the union. In this example, a single call to \nickel{f} that would be the
witness of the violation of the whole contract doesn't even exist: a minimum of
two are always needed.

This behavior indicates that union contracts introduce side-effects. The result
of \nickel{f 5} now depends on the previous execution and more specifically on
any prior call to \nickel{f}. This behavior of union contracts break the
property~\ref{eq:cbn-expansion} introduced in Section~\ref{sec:optimizations},
that is required to perform CSE-like optimizations in all generality. The
candidate example of Figure~\ref{fig:optimizations-let-floating-ex} in
Section~\ref{sec:optimizations} can't be optimized in general.

Figure~\ref{fig:optimized-programs} illustrates this point further. It contains
an original program and an optimized version where the common subexpression
\nickel{f 1} has been eliminated. While equivalent in a pure language without
contracts, these two programs behave differently because of unions:

\begin{itemize}
    \item The original version returns \nickel{(1, "False")} without failing.
    \item The optimized version fails with a contract violation.
\end{itemize}

In the original version, each partial application \nickel{f 1} gives rise to a
fresh instance of the contract \nickel{Bool -> Num @| Bool -> Str}. These
instances are independent, and can pick a different component of the union to
satisfy. Although \nickel{f} doesn't actually respect the contract, these calls
are not enough to prove so. In the optimized version, \nickel{g} is endowed with
a single contract, that must pick one of the two components of the union. There,
the two calls refer to the same union contract, and shows that \nickel{f} does
violate its initial contract.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=Original]
let f | Num -> (Bool -> Num @| Bool -> Str)
      = fun x y => if y then x else "False"
in (f 1 true, f 1 false)
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=Optimized]
let f | Num -> (Bool -> Num @| Bool -> Str)
      = fun x y => if y then x else "False"
let g = f 1 in
(g true, g false)
\end{lstlisting}
\caption{Equivalent programs, with inlining or CSE applied}
\label{fig:optimized-programs}
\end{figure}

\unsure{These arguments should go in the purity section}
To sum up, the addition of union contracts introduce side-effects in a pure
language. Side-effects have well-known pitfalls:
\begin{itemize}
    \item For the programmer, they are hard to reason about. They prevent local
        reasoning. In our previous examples, removing or adding a function call
        somewhere can toggle a failure in a call at a totally different
        location.
    \item For the interpreter (or compiler), side-effects inhibit many optimizations and
        program transformations.
\end{itemize}


% A valid argument against this point would be stating that further work should be done
% on optimizers, so to not modify these tricky cases, even if this is true,
% programmers also modify their code on a daily basis, and if moving from the first
% code snippet at Figure \ref{fig:optimized-programs} to the second one changes
% the behaviour of a program, we argue that union contracts not only go against the
% implementation of languages, but also against their usability.
%
% Summing it up, wrapping a value with a union of higher order contracts means that
% that value now has a state, that may get modified silently at every use site.
% Both reviewed papers suffer from this defect since it is the semantics
% of unions that interact badly with code manipulation operations,
% not a particular implementation.
% This addition of global state complicates both the work of the language
% implementor, as well as the language user, since it adds non trivial
% side effects to your code.


\subsection{Intersection with user-defined contracts}
\label{sec:flat-and-inter}

A natural - but naive - implementation of intersection contracts could be the
following: to apply a contract \nickel{A @& B}, apply both contracts \nickel{A}
and \nickel{B} sequentially, resulting in the naive decomposition rule of
Figure~\ref{fig:naive-impl}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel,frame=none,numbers=none,title={Naive
decomposition}]
M | A @& B (*@ $\simeq$ @*) (M | A) | B
\end{lstlisting}
\begin{lstlisting}[language=nickel,frame=none,numbers=none,title={Exchange law}]
(A -> B) @& (C -> D) (*@ $\simeq$ @*) (A @& C) -> (B @& D)
\end{lstlisting}
\begin{lstlisting}[language=nickel,title={Overloaded identity}]
let g | Num -> Num @& Str -> Str
      = fun x => x in
g 1
\end{lstlisting}
\caption{Naive implementation of intersection}
\label{fig:naive-impl}
\end{figure}

This intuition works for simple contracts: checking that \nickel{x | Natural @&
Odd} amounts to check that \nickel{x | Natural} and \nickel{x | Odd}.
Unfortunately, this doesn't scale to higher-order contracts.  The overloaded
identity example of Figure~\ref{fig:naive-impl} illustrates the use of an
intersection to model a simple overloading of the identity function. If we were
to apply the naive decomposition, the argument \nickel{1} would fail the
\nickel{Str -> Str} contract and abort the execution. Perhaps the exchange rule
given in Figure~\ref{fig:naive-impl}, which is a direct consequence of the naive
decomposition, illustrates the issue better. It is clear that this exchange law
isn't the right semantics for overloading. With this law, the contract for
overloaded identity of Figure~\ref{fig:naive-impl} would always fail because
no argument can satisfy \nickel{Num @& Str}.

% Stop for a second and think how you could implement an intersection contract.
% The first thought you may have is "just apply both contracts", as shown on the
% Implementation snippet from Figure \ref{fig:inter-contracts}.  Of course, if
% it were that simple we wouldn't be writing this paper.  This idea starts to
% show problems when you first combine it with higher order contracts, since it
% would mean not complying with at least one of these contracts negatively would
% entail breaking the whole thing, as shown on the second example on the same
% Figure, that would fail.

In an higher-order intersection contract, blame is raised when:
\begin{description}
    \item[Faulty caller] The argument fails \emph{both} components.
    \item[Faulty implementation] The function fails \emph{one} component that the
        argument previously satisfied.
\end{description}

% Not all hope is lost, we could pass some extra shared state
% to each one of the sub contracts and let them only fail if the other
% side of the contract has failed as well, as shown in Figure
% \ref{fig:inter-contracts-2}, where the shared state is
% represented by a label \nickel{l}.
% This idea is still quite reasonable, for instance, when executing
% \nickel{g 1}, from Figure \ref{fig:inter-contracts}, the first contract
% that gets checked is the argument of \nickel{Str -> Str} over the function parameter, so
% something like \nickel{1 | Str}.
% Of course, this fails, but before raising a violation, this contract could
% check if the other side of the intersection (\nickel{Num -> Num}) has
% also tried to raise negative blame on the same parameter ()\nickel{1}), since
% it hasn't, the contract would return normally, and would mark itself as failed.

% On the other hand, if you were to do something like
% \nickel{g true}, that would fail also negatively the contract
% \nickel{Str -> Str} and, when checking if \nickel{true}
% is a correct parameter for \nickel{Num -> Num} it would check
% if the other side of the intersection has failed, and since it
% has, a violation would be raised and the whole program would
% correctly fail.
%
% This idea, which is an oversimplification of the ideas
% presented by Williams, Morris, and Wadler, seems to be spot on.

To fix the naive implementation, the interpreter can share state between the
sub-contracts, in order to decide if blame must be raised or not when a
sub-contract fails:

\begin{lstlisting}[language=nickel,frame=none,numbers=none]
x | A @& B (*@ $\simeq$ @*) (x | A[l]) | B[l]
\end{lstlisting}

Shared state is represented by the label \nickel{l}. This is in essence the
approach proposed by Williams, Morris, and Wadler in~\cite{RootCauseOfBlame}.

% \begin{figure}[h]
% \begin{lstlisting}[language=nickel, title=Implementation]
% x | A @& B (*@ $\simeq$ @*) (x | A[l]) | B[l]
% \end{lstlisting}
% \caption{Implementations of intersection contracts: second iteration}
% \label{fig:inter-contracts-2}
% \end{figure}


% However, it presents a major problem, it's not compatible with user defined contracts,
% as presented in Section \ref{sec:flat-contracts}.
% Consider the example presented on Figure \ref{fig:inter-flat-contracts}, if the
% implementation discussed previously were to be used, we may end up with
% something like this \nickel{((fun x => x) | (Str -> Str)[l]) | C[l]}, where
% \nickel{l} represents the shared state.
% At this point, the intuitive thing to do is to check the contract \nickel{C}, by
% checking if \nickel{((fun x => x) | (Str -> Str)[l]) 0 == 0}.  This will fail,
% since applying a function wrapped in \nickel{Str -> Str} contract to \nickel{0}
% fails negatively.

However, their approach has a major drawback: it is not straightforwardly
compatible with user-defined contracts (introduced in Section
\ref{sec:flat-contracts}). The issue is similar to our initial issue with higher-order
contracts and the naive decomposition: user-defined contracts may apply
functions and thus make a sub-contract of the intersection fail, but this
failure shouldn't always result in raising blame. An example is given on Figure
\ref{fig:inter-flat-contracts}. Decomposing using the shared state approach, we
end up with:

\begin{lstlisting}[language=nickel,frame=none,numbers=none,title={Stateful
decomposition}]
((fun x => x) | (Str -> Str)[l]) | C[l]
\end{lstlisting}

where \nickel{l} represents the shared state.  At this point,
applying the \nickel{C} contract results in evaluating:

\begin{lstlisting}[language=nickel,frame=none,numbers=none]
((fun x => x) | (Str -> Str)[l]) 0 == 0.
\end{lstlisting}

Applying a function wrapped in a \nickel{Str -> Str} contract to \nickel{0}
fails negatively. This is not the expected behavior, since the identity function
does respect semantically both contracts. As opposed to built-in higher-order
contracts, user-defined contracts are black-box from the interpreter's point of
view, and it is thus not obvious how to extend the shared state approach to
handle user-defined contracts. The authors of~\cite{RootCauseOfBlame}
acknowledge this fact: they decide to simply drop user-defined contracts
altogether.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let c = contracts.frompred (fun f =>
  f 0 == 0) in
let g | (string -> string) @& c
      = fun x => x
\end{lstlisting}
\caption{intersection and user defined contracts}
\label{fig:inter-flat-contracts}
\end{figure}

Once again, intersection contracts introduce side-effects in the picture. What's
more, these side-effects interact with user-defined contracts in a non-trivial
way, while they are an important feature for validation.
\unsure{(Yann) Should we talk about thiemann here, who do support user-defined
contracts?}
% But this should not have happened, since in the program of Figure
% \ref{fig:inter-flat-contracts} \nickel{g} is never applied to \nickel{0}, in
% fact, it is never applied to anything.  Checking if \nickel{C} has already
% failed, and marking \nickel{String -> String} as failed negatively on \nickel{l}
% is not enough, the contract \nickel{String -> String} should not have been used
% inside the evaluation of \nickel{C}, which adds an extra layer of complexity:
% contracts should be guarded, and execution depends on the shape of the
% surrounding evaluation context.


\subsection{Challenging the semantics}


Previous points of this section were about how implementing the expected
semantics for union and intersection has a profound impact on the language. Let
us end the section by investigating a different aspect: does the
semantics correspond to the programmer's intuition?

But which semantics? We deemed the exchange law of Figure~\ref{fig:naive-impl}
as ``clearly wrong'' with respect to overloading. There is nothing wrong per se :
we could chose a semantics for intersections that validate this rule.  However,
the resulting system wouldn't capture overloading, and is arguably not very
interesting nor useful. In~\cite{KeilThiemannUnionIntersection}, the authors
argue for basing the semantics of contracts on union and intersection type
systems, which have a simple and natural definition from which the other
properties follow. This approach makes sense, and has been continued in future
works, and in particular in~\cite{RootCauseOfBlame}.

But even this semantics is no panacea. Figure~\ref{fig:intersection-distribution}
shows an example that intuitively looks like it should succeeed, returning
\nickel{(1, 1)}. However, under the semantics used both
in~\cite{KeilThiemannUnionIntersection} and~\cite{RootCauseOfBlame}, this program
fails with a contract violation.

% Before wrapping up the section, we would like to show that maybe, union and
% intersection contracts are not exactly what we would want them to be.  As stated
% throughout this work, programmers coming from dynamic languages are accustomed
% to perform safety checks (data validation) with great amounts of flexibility and
% the whole power of their language of choice at their disposal.
%
% For instance, a Python programmer may have no problem in checking at runtime,
% that a given variable is an integer if a given flag is not set, as shown in
% Figure \ref{fig:python-assertion}; while a Haskell programmer might close her
% eyes and leave the room instantly.
%
% \begin{figure}[h]
% \begin{lstlisting}[language=python]
% result = 42 if flag else "Disabled"
% ...
% assert (
%   (not flag)
%   or isinstance(result, int)
% )
% \end{lstlisting}
% \caption{Asserting at runtime the type of a variable}
% \label{fig:python-assertion}
% \end{figure}
%
% These expectations are not really met by how unions and intersections
% contracts are supposed to work.
% For example, consider the Nickel code shown on Figure
% \ref{fig:intersection-distrbution}, at first sight, this code should
% complete execution successfully, returning \nickel{(1, 1)},
% however, under both the Keil and Thiemann, as well as the
% Williams, Morris, and Wadler works, this program will fail, with a violation
% of the contract imposed to \nickel{g}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f = fun x y => x in
let g = f | (Num -> Num -> Num)
            @& (Num -> Bool -> Num) in
let h = g 1 in
(h 1, h true)
\end{lstlisting}
\caption{Intersection contracts don't distribute}
\label{fig:intersection-distribution}
\end{figure}

This discrepancy is inherent to the chosen semantics .  When applying a function
with an intersection contract, only one component of the intersection must be
selected for the function. The actual choice of component may be delayed to
later, but the point is that it must be the same across all usages. In
Figure~\ref{fig:intersection-distribution}, the contract for \nickel{h} can in
consequence be either \nickel{Num -> Num} or \nickel{Bool -> Num}, but not both.
This is a manifestation of the following more general defect: the distributivity
law given in Figure~\ref{fig:distributivity-law} is not valid in the semantics
given in~\cite{KeilThiemannUnionIntersection}, while it is both sound to add and
intuitive.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
A -> B @& A -> C (*@ $\simeq$ @*) A -> (B @& C)
\end{lstlisting}
\caption{Distributivity law}
\label{fig:distributivity-law}
\end{figure}

Curiously, union and intersection type systems, on which
\cite{KeilThiemannUnionIntersection} are basing their semantics on, don't
exhibit this property. Subtyping allows to correctly type check a term like
\nickel{g 1} as both \nickel{Num -> Num} as well as
\nickel{Bool -> Num}, and then deducing that \nickel{g 1}
can be given the type \nickel{Num -> Num @& Bool -> Num}.
\unsure{(Yann) I just reworked the wording, but I'm not totally sold on the
argument}

\section{Pragmatic trade-offs}
\label{sec:issues-literature}

Despite the difficulties of Section~\ref{sec:issues-sem}, union and
intersection contracts are still sought after. In this section we turn
to existing systems with union and intersection contracts in the
literature and in implementations.

These systems all make trade-offs, sacrificing some features of union
and intersection contracts to preserve language features. We survey
and discuss those trade-offs and their implications.

\subsection{Keil and Thiemann}
\label{sec:keil-thiemann}
\unsure{Subsection title?}

In Section~\ref{sec:issues-sem}, we've seen that different calls to a function
with a union contract must share information: the behavior of one call is
influenced by the previous ones, as the function must pick one component of the
union to satisfy across all usages. Conversely, following the semantics of
overloading, each application of a function with an intersection contract can
select a different branch and is thus independent from the others. A general
contract composed of nested unions, intersections and higher-order contracts
appears to require complex book-keeping in order to correctly raise blame.

An aspect of the approach of~\cite{KeilThiemannUnionIntersection} is to rewrite
these nested contracts using the De Morgan law of
Figure~\ref{fig:de-morgan-law}, eagerly opening up unions while postponing
intersection as much as possible.  \todo{This assumes the difficulty has been
previously explained} This transformation flattens arbitrarily nested unions and
intersections to a union of intersections, making blame resolution more
manageable.\unsure{(Yann) find better (more precise) wording}

\begin{figure}[h]
\begin{lstlisting}[frame=none, numbers=none, language=nickel]
A @& (B @| C) (*@ $\simeq$ @*) (A @& B) @| (A @& C)
\end{lstlisting}
\caption{De Morgan law for contracts}
\label{fig:de-morgan-law}
\end{figure}

To implement this solution, \cite{KeilThiemannUnionIntersection} resorts to
specific reduction rules for unions and intersections which perform this
rewriting on the fly. The result is that the reduction rules sometimes feel
ad-hoc, and make us question the composability and extensibility of the system.
In the words of Williams, Morris, and Wadler (see
Section~\ref{sec:will-morr-wadl}): ``(\ldots) the monitoring semantics for
contracts of intersection and union types given by Keil and Thiemann are not
uniform. (\ldots) If uniformity helps composition, then special cases can hinder
composition.'' \cite{RootCauseOfBlame}. Another less important consequence is
that in Figure~\ref{fig:de-morgan-law}, the contract \nickel{A} is duplicated,
potentially causing additional work. If \nickel{B} fails, \nickel{A} will be
re-evaluated in each branch of the right hand side of
Figure~\ref{fig:de-morgan-law} in the absence of an additional sharing
mechanism.
\resolved{(Yann) Does
it also make it less efficient? If $(A \cap B)$ fails because of $B$, their
development causes to recheck the contract $A$ that has been duplicated?}
\unsure{Arnaud says: this whole
section is too abstract give concrete code and explain what goes
wrong. It's fine to give code in Nickel syntax}

One important advantage of~\cite{KeilThiemannUnionIntersection} is to handle
user-defined contracts. We explained in Section~\ref{sec:issues-sem} why a
direct approach for higher-order intersection contracts (as done
in~\cite{RootCauseOfBlame}) is not trivial to adapt for user-defined contracts.
\cite{KeilThiemannUnionIntersection} provides two operational semantics of the
contract system: a non-deterministic one, more intuitive and proof-friendly, and
a deterministic one for actual implementation. The non-deterministic semantics
cleanly handle intersections with user-defined contracts: as each component is
checked in a separate thread, there is no direct interaction.

Let us recast the problematic example of Figure~\ref{fig:inter-flat-contracts}
in Figure~\ref{fig:inter-flat-contracts-2}). The execution now splits the
intersection into two sub-contracts that are checked separately. If one
component fails, a flag in a global state. In particular, the two threads don't
interact directly, and don't raise blame by themselves, leading this example run
as expected.

\begin{figure}[h]
\begin{lstlisting}[language=nickel,title={Original program}]
let C = contracts.fromPred (fun f =>
  f 0 == 0) in
let g | (String -> String) @& C
      = fun x => x
in g 0
\end{lstlisting}
\begin{lstlisting}[numbers=none,title={First component}]
g 0 | Str -> Str
\end{lstlisting}
\begin{lstlisting}[numbers=none,title={Second component}]
g 0 | C
\end{lstlisting}
\caption{Intersection and user defined contracts}
\label{fig:inter-flat-contracts-2}
\end{figure}

In return, the complexity is offloaded to a separate procedure that must decide
when to raise blame. This complexity is salient in the deterministic, sequential
version~\cite[Section 5.1]{KeilThiemannUnionIntersection}. There,
the evaluation procedure has to deal again with the problem of eliding contracts
that are not \emph{compatible}~\cite[Section 5.1]{KeilThiemannUnionIntersection} (contracts are incompatible
if they are coming from a different branch and should be ignored). In practice,
the evaluation procedure maintains a global environment of contracts that is
extended each time a non-trivial contract (union, intersection or higher-order)
is opened. Then, any contract application must check the presence of the
corresponding label in the environment. What's more, each time a function with a contract attached is applied,
the whole \emph{context} (that is, the continuation of the application) must be
must be checked for compatibility with respect to each label of the contract
environment. Checking for compatibility involves searching the context for
contract applications.

Keil and Thiemann realize the tour de force of combining union and intersection
contracts with user-defined contracts. The price to pay, though, is that
implementing their solution in a reasonable way is far from obvious. Not only
when starting from the more abstract, non-deterministic formulation, but even
when starting from the algorithmic version of their system.


% Another difficult issue Keil and Thiemann were able to solve, is the
% fact that user defined contracts and intersection do not usually play nice
% together, as shown on Section \ref{sec:flat-and-inter}.
% They provide two different sets of rules for their calculus,
% the first one is non deterministic, and its purpose is to provide
% semantics that are simple to understand.
% With these rules, the interaction between user defined contracts and
% intersections becomes much simpler, since they are able to check
% both sides of an intersection on separate threads.
% This allows them to be sure that contracts from one branch of the intersection
% won't get blamed while executing the other branch, and vice versa.
%
% As an example, consider the programs shown on Figure
% \ref{fig:kt-non-deterministic}, if the Original program
% gets executed, it will spawn two instances of said program,
% one with the first branch of the intersection (\nickel{3 | Num}),
% and the other one with the second branch (\nickel{3 | Positive}),
% and these will get joined once they reach an equal point, in this case
% it will be \nickel{3}.
%
% \begin{figure}[h]
% \begin{lstlisting}[language=nickel, title=Original]
% 3 | Num @& Positive
% \end{lstlisting}
% \begin{lstlisting}[language=nickel, title=First Program]
% 3 | Num
% \end{lstlisting}
% \begin{lstlisting}[language=nickel, title=Second Program]
% 3 | Positive
% \end{lstlisting}
% \begin{lstlisting}[language=nickel, title=Joined Program]
% 3
% \end{lstlisting}
% \caption{Non deterministic intersection contract opening}
% \label{fig:kt-non-deterministic}
% \end{figure}
%
% The second set of rules is deterministic, and it is intended
% to be simpler to implement.
% However, this second set needs to perform operations
% on the evaluation context, to decide whether or not to evaluate
% a given contract.
% \footnote{You can check more on this topic on Section 5.1 of
% \cite{KeilThiemannUnionIntersection}}
% For instance, in the program presented on Figure \ref{fig:inter-flat-contracts},
% when using the value \nickel{(fun x => x) | Str -> Str)}
% inside the execution of contract \nickel{C}, and applying it to \nickel{0},
% the contract runtime would check the context of execution and it would
% deduce that contract \nickel{Str -> Str} does not apply in this case,
% skipping it.
%
% We see two problems here, a minor one is the fact that the two
% different semantics defined for the calculus are really far apart
% one from the other, both on the strategies used for contract resolution,
% as well as on the complexity levels.
\resolved{(Yann) Is it really a
    problem per se? It is common thing to do (a nice declarative system
    for proofs and an algorithmic one for implementation, proved equivalent).
    Maybe the point is that the algorithmic system is way more complex than the
declarative one
(Teo) reworded}.
% A second, major one,
% is the dependency added over the evaluation context, since, again,
% it makes composing this, with other features desired on programming languages,
% difficult, or even impossible.
\resolved{(Yann) I think we need to substantiate this claim. If this
context dependency explains why CSE is invalid, maybe have a little example?
(Teo) I removed it, I don't think there's an example, mainly since
this context dependency is not part of the language. I do think it complicates
implementation of said feature}
\todo{(Yann) TODO: see if there's a low hanging complexity
    argument we can make (like it's quadratic in the number of open contracts or
whatever)}

\subsection{Williams, Morris, and Wadler}
\label{sec:will-morr-wadl}
\unsure{Subsection title?}

As mentioned in Section~\ref{sec:issues-sem}, Williams, Morris, and Wadler,
downright exclude user-defined contracts from the picture. This choice gives
them more freedom in the quest of a more uniform operational semantics. While
this can be a sensible choice (in a gradual typing context e.g.), this is a show
stopper for our initial use-case of the Nickel configuration language, the main
motivation being to use contracts as customizable validation functions.

On the semantic side, one of the so-called the sound monitoring properties
linking the operational semantics to the denotational semantics (supposed to
capture the intuitive interpretation) is at odds with the given interpretation.
% On top of that, a fundamental problem arises on said paper,
% symptom of the difficulty of establishing good enough, and yet
% simple semantics for union and intersection dynamic checks.
% One of their main results, is the fact that their calculus obeys
% all of their expected monitoring properties for higher ordered, union
% and intersection contracts.

For a contract $A$, $\llbracket A \rrbracket^+$ defines the set of terms that
satisfy $A$. For example,

\begin{lstlisting}[language=nickel,frame=none,numbers=none]
    if true then 1 else "a" (*@$\in \llbracket Num \rrbracket^+$@*)
\end{lstlisting}

For higher-order contracts, the notion has two facets. A \nickel{Num -> Str}
contract can be violated in two ways: by the function returning a value that is
not a string, or by the caller providing an argument that is not a number.  The
former is embodied by the same notion as before: $f \in \llbracket Num \to Str
\rrbracket^+$ if whenever $f$ receives a number, it returns a string.  One
important contribution of~\cite{KeilThiemannUnionIntersection}, upon
which~\cite{RootCauseOfBlame} builds upon, is to extend the notion of contract
satisfaction to \emph{contexts} (i.e. a continuations), embodying the caller's
obligations. A context $K$ is a term with a hole to be filled with a term (see
Figure~\ref{fig:valid-contexts} for examples). Then, $K \in \llbracket Num \to
Str \rrbracket^-$ (the context $K$ satisfies the contract \nickel{Num -> Str})
if it only applies the hole to arguments satisfying the \nickel{Num} contract.

These interpretations $\llbracket . \rrbracket^+$ and $\llbracket .
\rrbracket^-$ then need to be extended to the setting of unions and
intersections. In particular, one of the definitions of~\cite{RootCauseOfBlame}
is the following:

\begin{figure}[h]
$$ K \in \llbracket A \cap B \rrbracket^-~if~K \in \llbracket A \rrbracket^- \lor K \in \llbracket B \rrbracket^- $$
\caption{Sound monitoring property for intersection from~\cite{RootCauseOfBlame}}
\label{fig:wmw-semantics}
\end{figure}

This reads as: a context $K$ satisfies the intersection of $A$ and $B$ if it
satisfies at least one of the two. Morally, the $K$s in $\llbracket A \cap B
\rrbracket^-$  should be the ones that can have their hole filled with a term
satisfying $A \cap B$ without violating the $A \cap B$ contract.

Although valid, this interpretation is weaker than what~\cite{RootCauseOfBlame}
actually describes it to be and than the semantics given
in~\cite{KeilThiemannUnionIntersection}. Consider the two contexts presented on
Figure~\ref{fig:valid-contexts}. The first one is a context satisfying
\nickel{Num -> Num}, applying the hole to a number. Similarly, the second context
from the same figure satisfies \nickel{Bool -> Bool}.

\begin{figure}[h]
\begin{lstlisting}[language=nickel, title=\nickel{Num -> Num} context]
(*@$\square$@*) 3
\end{lstlisting}
\begin{lstlisting}[language=nickel, title=\nickel{Bool -> Bool} context]
(*@$\square$@*) true
\end{lstlisting}
\caption{Two different contexts in Nickel}
\label{fig:valid-contexts}
\end{figure}

Now, combining these two context as in~\ref{fig:invalid-context} gives a context
that doesn't satisfy \nickel{Num -> Num} nor \nickel{Bool -> Bool}.  According
to the semantics of~\cite{RootCauseOfBlame}, it thus doesn't satisfy \nickel{Num
-> Num @& Bool -> Bool}. Yet, our intuition tells us that this example is a
perfectly valid context for this contract: an overloaded function satisfying
both \nickel{Num -> Num} and \nickel{Bool -> Bool} can safely be applied to a
number and to a boolean in a row. And indeed, the denotational semantics given
in~\cite{KeilThiemannUnionIntersection} does accept this context as valid.

The issue is not as bad as it sounds: the system presented
in~\cite{RootCauseOfBlame} actually corresponds to the wished, stronger
semantics in practice. The specification is just not exactly the right one, but
this can probably be fixed along the lines
of~\ref{KeilThiemannUnionIntersection}, where the notion of context used to
define satisfaction is carefully restricted (\emph{elimination contexts}). While
this kind of oversight doesn't lower the quality of the work
of~\ref{RootCauseOfBlame} by any measure, it illustrates that contract
satisfaction in presence of unions, intersections and functions is a tricky
notion. This difficulty contrasts with the standard framework of higher-order
contracts where satisfaction is much more straightforward.
% Next, we can combine these two contexts into one, that essentially
% has one single missing value, that will be used independently in both contexts
% from Figure \ref{fig:valid-contexts}, as shown on Figure \ref{fig:invalid-context}.
% This context is not a valid \nickel{Num -> Num} context, since it will apply
% the value put on $\square$ (through \nickel{f}) to a non \nickel{Num} (\nickel{true}).
% In a similar way, it is not a valid \nickel{Bool -> Bool} context either.
% Therefore, according to the semantics from the Williams, Morris, and Wadler paper, as
% shown on Figure \ref{fig:wmw-semantics}, it is not a valid
% \nickel{Num -> Num @& Bool -> Bool} context.

\begin{figure}[h]
\begin{lstlisting}[language=nickel]
let f = (*@$\square$@*) in
(f 3, f true)
\end{lstlisting}
\caption{Combined context}
\label{fig:invalid-context}
\end{figure}

% However, both our intuition, as the most common use case of intersections
% (that is, overloading), tells us that this should work.
% While this problem does not invalidate their work (in fact, the system they present
% handles these cases correctly), it shows that existing research is still not on
% good shape to handle the growing usecases being developed for
% unions and intersections around dynamic languages.

% $$ K ::= Id | K \bullet \square N | K \bullet V \square | K \bullet \square @^pA  $$

% Keil and Thiemann did noticed this problem, and their contract satisfaction
% rules only apply to elimination context, a particular kind of context
% where the hole is either being applied to an argument
% ($\square N$) or is used as an argument for a primitive
% operation ($O(\overrightarrow{\text{V}}, \square, \overrightarrow{\text{N}})$).


% K ::= Id | K ◦ □ N | K ◦ V □ | K ◦ □ @pA
\resolved{(Yann) Maybe adding a concrete example of this (it can be the same term but with
    concrete types like Number and String and simple contexts like application
    to a dumb argument) is sufficient to make the point}

\subsection{Racket}
\label{sec:racket}

Racket is a language based on the Scheme dialect of Lisp. Among established
languages, Racket is probably the one with the most comprehensive contract
system\cite{RacketContracts}. Regarding union and intersections, Racket provides
the \racket{and/c} and \racket{or/c} combinators for contract.  These
combinators correspond to the naive interpretation of unions and intersections
(as in Figure~\ref{fig:naive-impl}): \racket{and/c} (resp.  \racket{or/c})
simply checks sequentially that all (resp. one) contracts pass.  In consequence,
unions or intersections of higher-order contracts don't match intuition, and in
particular intersections don't model overloading. As in
Figure~\ref{fig:naive-impl}, the example given in
Figure~\ref{fig:racket-overloading} always fail because no argument satisfies
both \racket{number?} and \racket{string?}.

% Among those contracts, they provide \racket{and/c} and \racket{or/c} contracts.
% These contracts are lightweight versions of intersections and unions, they simply
% check that every contract is valid, in the case of \racket{and/c},
% and that at least one contract
% is valid, in the case of \racket{or/c}.

% So, for instance, the usual usecase of intersection to encode bounded overloading
% does not work on Racket. Take a look at the next example, the function
% \racket{overload} should accept a call like \racket{(overload 3)}, but it fails
% since 3 is not a valid \racket{string?}.

\begin{figure}[h]
\begin{lstlisting}[language=racket]
(define/contract overload
(and/c (-> number? number?)
       (-> string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{\racket{and/c} and overloading}
\label{fig:racket-overloading}
\end{figure}

When higher-order contracts are combined using \racket{or/c}, Racket imposes
that contracts must distinguishable by their arity. Doing so, there is at most
one candidate that can be selected directly. This is illustrated in
Figure~\ref{code:racket:or/c:working} whose program is accepted. On the other
hand, the program of Figure~\ref{code:racket:or/c:non-working} is rejected.

% that could (potentially) apply to a function, these have to be
% differentiated by first order markers.
% For instance, the code on Figure~\ref{code:racket:or/c:working}
% would correctly allow only to call
% \racket{united} with a \racket{number?},
% and it can make this distinction since it knows that
% \racket{(lambda (x) x)} can not be a function that takes 2 parameters.
% However, the code on Figure~\ref{code:racket:or/c:non-working} would fail
% before running, since the \racket{or/c} contract is unable to know
% which of the two function contracts to use.
% Ideally, this last example should just behave as wrapping
% the function with the \racket{(-> even? even?)} contract.

\begin{figure}[h]

\begin{lstlisting}[language=racket]
(define/contract united
(or/c (-> number? number?)
      (-> string? string? string?))
(lambda (x) x))
\end{lstlisting}
\caption{Accepted use of \racket{or/c} with higher-order contracts}
\label{code:racket:or/c:working}

\end{figure}

\begin{figure}[h]

\begin{lstlisting}[language=lisp]
(define/contract united
(or/c (-> number? number?)
      (-> even? even?))
(lambda (x) x))
\end{lstlisting}
\caption{Rejected use of \racket{or/c} with higher-order contracts}
\label{code:racket:or/c:non-working}

\end{figure}


\unsure{This section is overall a bit hard to follow. I
  think I've figured out what it means, but it needs more love. Also
  give an example which doesn't work and one that does for or/c.}

\subsubsection{case->}

Racket does provide the \racket{case->} combinator which(partially) supports
overloading. As for the \racket{or/c}, the candidate contracts must have
distinct arities to avoid ambiguity. An example is provided in
Figure~\ref{fig:rafig:racket-case-fun}. The resulting possibilities are similar
to static overloading, where one function can take additional parameters for
example (e.g. as supported for Java methods). Unfortunately, it excludes the
overloading of generic operations with fixed arity such as equality, comparison,
arithmetic operators, and so on.

% Racket does provide an alternative for overloading methods, called the
% \racket{case->} contract, however, this overloading of methods only
% works over contracts of functions with different amount of parameters.
% It's a good alternative to allow limited overloading of functions.
% As an example, consider the following non failing piece of code, and
% try to understand how Racket can decide, at each application,
% which function contract to use.

\begin{figure}[h]
\begin{lstlisting}[language=racket]
(define/contract overcase
  (case-> (-> string? string?)
          (-> number? number? number?)
          )
  (lambda (x [y 0]) (if (number? x)
                   (+ x y)
                   x)))

(overcase 1 2)

(overcase "hello")
\end{lstlisting}
\caption{Overloading with the \racket{case->} combinator}
\label{fig:racket-case-fun}
\end{figure}

In conclusion, Racket also seems to avoid the difficulties of general unions and
intersections. They make the pragmatic choice of a simple semantics that work
for non higher-order contracts and a limited support for overloading.
% Even if Racket's intent is not to implement union and intersection
% dynamic checks, they do provide contracts that are, in some sense,
% simplified versions of those.
% In our eyes, Racket has accepted the difficulty of correctly and practically
% combine union, intersection, and higher order contracts, and has choose
% to prioritise the highe order ones.

\section{(More) Related work}
\label{sec:related-work}
\info{Including a mention of statically typed systems with union}

\unsure{WARNING: what is below is being reworked by Yann}

\subsection{Higher-order contracts}

Enforcing pre- and post-conditions at runtime is a widely established practice.
In their foundational paper\cite{FindlerFelleisenHOContracts}, Findler and
Felleisen introduce higher-order contracts, a principled approach to run-time
assertion checking that nicely supports functions. They introduce the notion of
blame, which is crucial to good error reporting. It became apparent later that
their contracts are closely related to the type casts introduced by gradual
typing, excluding blame: both \cite{FindlerMultiLang} and
\cite{FelleisenInterLang} see the value of contracts as a safe interface between
typed and untyped code. In \cite{WellTypedBlamed}, the authors precisely
introduce a system integrating gradual typing with contracts \textit{à la
Findler \& Felleisen}. Nickel adopts a similar type system, with both statically
typed terms, dynamically typed terms, and first-class contracts. Higher-order
contracts are the basis of the work~\cite{KeilThiemannUnionIntersection}
and~\cite{RootCauseOfBlame} that this paper explorted extensively.

\subsection{Unions and intersections in gradual typing}

Castagna et. al \cite{gradualCastagna} introduce a gradual type system based on
so-called set-theoretic types~\cite{SetTheoreticTypes}.  Set-theoretic types
feature unions, intersections, negation types together with a notion of
subtyping. This work adheres to the \emph{static first school} (see
~\cite{practiceTheoryGrad}) of gradual typing: the reason for gradual types is
to allow for a less precise type information. It follows that their goals and
constraints are somehow different, resulting in the absence of first-class
contracts. As for any gradual type system, they do have to implement casts -
that are very close to contracts - for unions and intersections, but these casts
are neither visible nor available to the programmer. Obviously, no contracts
mean no user-defined contracts as well.

The implementation of casts relies on abstract interpretation, leading to a
complex specification, whose implementation is straightforward. It is not clear
either how much these casts rely on static type information to function
correctly, possibly hampering their transformation to more general standalone
contracts.

\section{Conclusion}
\label{sec:conclusion}

The design and implementation of programming languages is a challenging task. It
is a delicate exercise to balance complexity, expressivity, efficiency, and user
experience all together. Unfortunately for designers, a language cannot usually
be reduced to a simple sum of small independent features. They are rather
composed of a lot of moving parts that interact in unexpected ways. The more a
language grows, the more any new addition has to be weighted carefully, as it
has the potential to interact with any of the existing features.

Part of recent developments revolves around improving safety of languages,
ideally with little to none effort required by the programmers.  Contracts are
crucial to this endeavour, they are fundamental to allow a safe interaction
between typed and untyped code in gradually typed languages; but they are also
interesting in themselves in a fully dynamically typed language (and even in a
fully statically typed language). Contracts are a precious idiom for data
validation or to enforce runtime pre- and post-condition that would be hard to
ensure statically.

% In spirit, contracts are similar to
% assertions, but they are part of a principled framework, they are composable,
% they have good error reporting and they are integrated as a language feature. In
% particular, contracts natively handles higher-order functions and built-in data
% structures. This makes them an great candidate for integration in the Nickel
% configuration language.

% This is only the beginning of the story. A language designer then has to choose
% what contract combinators to provide among a number of possibilities: there is
% the standard package including higher-order function contracts, record contracts
% and list contracts.  Then, one could add polymorphic
% contracts~\cite{BlameForAll}, dependent function
% contracts~\cite{DependentContracts}, and so on. For validation purpose, union and
% intersection contracts are really appealing. Unions have a intuitive
% interpretation as modeling alternatives and thus appear implicitly or explicitly
% in a lot of data structures.

When trying to enforce properties on dynamic languages, unions appear naturally,
since they allow to express that a variable is in an unknown state, but within
some bounded set of alternatives.  Sadly, the implementation of union and
intersection contracts is not as simple as it first appears. In conjunction with
higher-order contracts, they introduce side-effects in the language. These
behaviors were, for most of them, already known: we do not claim their
discovery. However, as language implementers, we have made an actual attempt at
including them in a concrete language. We exposed what, in our opinion, are the
most important barriers and their impact on the rest of the language. Even in a
pure setting, union and intersection contracts break the equivalence between
call-by-name and call-by-value, and can consequently prevent optimizations.
There are discrepancies between the expected and actual semantics that make some
behaviors unintuitive. Their implementation is a non-trivial change that
contaminates the evaluation of all other contracts, and the performance penalty
is not obvious to assess.

To conclude, let us make clear that we do not think union and intersection
contracts are fundamentally broken, that they can not be implemented correctly,
or that they do not bear any value (quite the contrary). They may still make
sense to have in a language, and some apparent difficulties in the
implementation could be lifted some day. But as often, there are gaps between
the theoretical foundation, a proof-of-concept, a prototype, and the integration
in an actual language. We hope that our attempt may serve as a cautionary tale:
for union and intersection contracts, these gaps might be quite large in places.

\bibliography{nickel}
\end{document}

% LocalWords:  Felleisen JSON TOML YAML templating Jsonnet Dhall MyPy
% LocalWords:  Kubernetes DevOps natively nixpkgs disjunctions
% LocalWords:  TypeScript serializable serialization
